// Code generated by Prisma Client Rust. DO NOT EDIT

pub static DATAMODEL_STR: &str =
    include_str!("/Users/kurbezz/books_project/book_library_server/prisma/schema.prisma");
static DATABASE_STR: &str = "postgresql";
pub async fn new_client() -> Result<PrismaClient, ::prisma_client_rust::NewClientError> {
    PrismaClient::_builder().build().await
}
pub async fn new_client_with_url(
    url: &str,
) -> Result<PrismaClient, ::prisma_client_rust::NewClientError> {
    PrismaClient::_builder()
        .with_url(url.to_string())
        .build()
        .await
}
pub mod author_annotation {
    
    use super::*;
    pub const NAME: &str = "AuthorAnnotation";
    pub mod id {
        use super::super::*;
        
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam,
        };
        pub const NAME: &str = "id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Id, {
            fn in_vec(_: Vec<i32>) -> InVec;
            fn not_in_vec(_: Vec<i32>) -> NotInVec;
            fn lt(_: i32) -> Lt;
            fn lte(_: i32) -> Lte;
            fn gt(_: i32) -> Gt;
            fn gte(_: i32) -> Gte;
            fn not(_: i32) -> Not;
        });
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideId(value)
        }
        pub struct Include;
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::Id(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::Id(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod author_id {
        use super::super::*;
        
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam,
        };
        pub const NAME: &str = "author_id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetAuthorId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::AuthorId(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::AuthorId(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
            UniqueWhereParam::AuthorIdEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntFilter,
            AuthorId,
            {
                fn in_vec(_: Vec<i32>) -> InVec;
                fn not_in_vec(_: Vec<i32>) -> NotInVec;
                fn lt(_: i32) -> Lt;
                fn lte(_: i32) -> Lte;
                fn gt(_: i32) -> Gt;
                fn gte(_: i32) -> Gte;
                fn not(_: i32) -> Not;
            }
        );
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementAuthorId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementAuthorId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyAuthorId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideAuthorId(value)
        }
        pub struct Include;
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::AuthorId(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::AuthorId(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod title {
        use super::super::*;
        
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "title";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetTitle(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Title(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Title(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::Title(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            Title,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::Title(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::Title(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod text {
        use super::super::*;
        
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "text";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetText(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Text(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Text(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::Text(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::StringFilter, Text, {
            fn in_vec(_: Vec<String>) -> InVec;
            fn not_in_vec(_: Vec<String>) -> NotInVec;
            fn lt(_: String) -> Lt;
            fn lte(_: String) -> Lte;
            fn gt(_: String) -> Gt;
            fn gte(_: String) -> Gte;
            fn contains(_: String) -> Contains;
            fn starts_with(_: String) -> StartsWith;
            fn ends_with(_: String) -> EndsWith;
            fn mode(_: super::super::QueryMode) -> Mode;
            fn not(_: String) -> Not;
        });
        pub struct Include;
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::Text(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::Text(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod file {
        use super::super::*;
        
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "file";
        pub struct Set(pub Option<String>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetFile(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::File(v)
            }
        }
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::File(direction)
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::File(_prisma::read_filters::StringNullableFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringNullableFilter,
            File,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: Option<String>) -> Not;
            }
        );
        pub struct Include;
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::File(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::File(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod author {
        use super::super::*;
        
        use super::{
            SetParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "author";
        pub struct Fetch(pub author::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<author::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Author(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(author::UniqueArgs::new())
        }
        pub struct Connect(author::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectAuthor(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: author::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn is(value: Vec<author::WhereParam>) -> WhereParam {
            WhereParam::AuthorIs(value)
        }
        pub fn is_not(value: Vec<author::WhereParam>) -> WhereParam {
            WhereParam::AuthorIsNot(value)
        }
        pub enum Include {
            Select(Vec<author::SelectParam>),
            Include(Vec<author::IncludeParam>),
            Fetch,
        }
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::Author(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections =
                            <author::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                            );
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <author::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("author", None, [], selections)
            }
            pub fn select(nested_selections: Vec<author::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<author::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<author::SelectParam>),
            Include(Vec<author::IncludeParam>),
            Fetch,
        }
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::Author(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <author::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("author", None, [], selections)
            }
            pub fn select(nested_selections: Vec<author::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<author::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub fn create(
        title: String,
        text: String,
        author: super::author::UniqueWhereParam,
        _params: Vec<SetParam>,
    ) -> (
        String,
        String,
        super::author::UniqueWhereParam,
        Vec<SetParam>,
    ) {
        (title, text, author, _params)
    }
    pub fn create_unchecked(
        author_id: i32,
        title: String,
        text: String,
        _params: Vec<SetParam>,
    ) -> (i32, String, String, Vec<SetParam>) {
        (author_id, title, text, _params)
    }
    #[macro_export]
    macro_rules ! _select_author_annotation { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $crate :: prisma :: author_annotation :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = $crate :: prisma :: author_annotation :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: author_annotation :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: author_annotation :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: author_annotation :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: author_annotation :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , author_id , title , text , file , author } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : crate :: prisma :: author_annotation :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: author_annotation :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: author_annotation :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: author_annotation :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: author_annotation :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: author_annotation :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "author_id" , "title" , "text" , "file" , "author"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: author_annotation :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i32 } ; (@ field_type ; author_id) => { i32 } ; (@ field_type ; title) => { String } ; (@ field_type ; text) => { String } ; (@ field_type ; file) => { Option < String > } ; (@ field_type ; author : $ selection_mode : ident { $ ($ selections : tt) + }) => { author :: Data } ; (@ field_type ; author) => { crate :: prisma :: author :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "AuthorAnnotation" , available relations are "id, author_id, title, text, file, author")) } ; (@ field_module ; author : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: author :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: author_annotation :: SelectParam > :: into (crate :: prisma :: author_annotation :: id :: Select) } ; (@ selection_field_to_selection_param ; author_id) => { Into :: < crate :: prisma :: author_annotation :: SelectParam > :: into (crate :: prisma :: author_annotation :: author_id :: Select) } ; (@ selection_field_to_selection_param ; title) => { Into :: < crate :: prisma :: author_annotation :: SelectParam > :: into (crate :: prisma :: author_annotation :: title :: Select) } ; (@ selection_field_to_selection_param ; text) => { Into :: < crate :: prisma :: author_annotation :: SelectParam > :: into (crate :: prisma :: author_annotation :: text :: Select) } ; (@ selection_field_to_selection_param ; file) => { Into :: < crate :: prisma :: author_annotation :: SelectParam > :: into (crate :: prisma :: author_annotation :: file :: Select) } ; (@ selection_field_to_selection_param ; author $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: author_annotation :: SelectParam > :: into (crate :: prisma :: author_annotation :: author :: Select :: $ selection_mode (crate :: prisma :: author :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; author $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: author_annotation :: SelectParam > :: into (crate :: prisma :: author_annotation :: author :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: author_annotation :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; author_id) => { "author_id" } ; (@ field_serde_name ; title) => { "title" } ; (@ field_serde_name ; text) => { "text" } ; (@ field_serde_name ; file) => { "file" } ; (@ field_serde_name ; author) => { "author" } ; }
    pub use _select_author_annotation as select;
    pub enum SelectParam {
        Id(id::Select),
        AuthorId(author_id::Select),
        Title(title::Select),
        Text(text::Select),
        File(file::Select),
        Author(author::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::AuthorId(data) => data.to_selection(),
                Self::Title(data) => data.to_selection(),
                Self::Text(data) => data.to_selection(),
                Self::File(data) => data.to_selection(),
                Self::Author(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_author_annotation { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $crate :: prisma :: author_annotation :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = $crate :: prisma :: author_annotation :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: author_annotation :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: author_annotation :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: author_annotation :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: author_annotation :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: author_annotation :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: author_annotation :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { author } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : i32 , pub author_id : i32 , pub title : String , pub text : String , pub file : Option < String > , $ (pub $ field : crate :: prisma :: author_annotation :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (author_id) , stringify ! (title) , stringify ! (text) , stringify ! (file)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: author_annotation :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: author_annotation :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: author_annotation :: author_id :: NAME , & self . author_id) ? ; state . serialize_field (crate :: prisma :: author_annotation :: title :: NAME , & self . title) ? ; state . serialize_field (crate :: prisma :: author_annotation :: text :: NAME , & self . text) ? ; state . serialize_field (crate :: prisma :: author_annotation :: file :: NAME , & self . file) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , author_id , title , text , file } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: author_annotation :: $ field :: NAME) , + , crate :: prisma :: author_annotation :: id :: NAME , crate :: prisma :: author_annotation :: author_id :: NAME , crate :: prisma :: author_annotation :: title :: NAME , crate :: prisma :: author_annotation :: text :: NAME , crate :: prisma :: author_annotation :: file :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: author_annotation :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: author_annotation :: id :: NAME => Ok (Field :: id) , crate :: prisma :: author_annotation :: author_id :: NAME => Ok (Field :: author_id) , crate :: prisma :: author_annotation :: title :: NAME => Ok (Field :: title) , crate :: prisma :: author_annotation :: text :: NAME => Ok (Field :: text) , crate :: prisma :: author_annotation :: file :: NAME => Ok (Field :: file) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut author_id = None ; let mut title = None ; let mut text = None ; let mut file = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: author_annotation :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: author_id => { if author_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: author_annotation :: author_id :: NAME)) ; } author_id = Some (map . next_value () ?) ; } Field :: title => { if title . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: author_annotation :: title :: NAME)) ; } title = Some (map . next_value () ?) ; } Field :: text => { if text . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: author_annotation :: text :: NAME)) ; } text = Some (map . next_value () ?) ; } Field :: file => { if file . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: author_annotation :: file :: NAME)) ; } file = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: author_annotation :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: author_annotation :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: author_annotation :: id :: NAME)) ? ; let author_id = author_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: author_annotation :: author_id :: NAME)) ? ; let title = title . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: author_annotation :: title :: NAME)) ? ; let text = text . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: author_annotation :: text :: NAME)) ? ; let file = file . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: author_annotation :: file :: NAME)) ? ; Ok (Data { id , author_id , title , text , file , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "author_id" , "title" , "text" , "file" , "author"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: author_annotation :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; author : $ selection_mode : ident { $ ($ selections : tt) + }) => { author :: Data } ; (@ field_type ; author) => { crate :: prisma :: author :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "AuthorAnnotation" , available relations are "author")) } ; (@ field_module ; author : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: author :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; author $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: author_annotation :: IncludeParam > :: into (crate :: prisma :: author_annotation :: author :: Include :: $ selection_mode (crate :: prisma :: author :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; author $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: author_annotation :: IncludeParam > :: into (crate :: prisma :: author_annotation :: author :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: author_annotation :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; author_id) => { "author_id" } ; (@ field_serde_name ; title) => { "title" } ; (@ field_serde_name ; text) => { "text" } ; (@ field_serde_name ; file) => { "file" } ; (@ field_serde_name ; author) => { "author" } ; }
    pub use _include_author_annotation as include;
    pub enum IncludeParam {
        Id(id::Include),
        AuthorId(author_id::Include),
        Title(title::Include),
        Text(text::Include),
        File(file::Include),
        Author(author::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::AuthorId(data) => data.to_selection(),
                Self::Title(data) => data.to_selection(),
                Self::Text(data) => data.to_selection(),
                Self::File(data) => data.to_selection(),
                Self::Author(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _partial_unchecked_author_annotation { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { $crate :: prisma :: author_annotation struct $ struct_name { # [serde (rename = "id")] pub id : i32 , # [serde (rename = "author_id")] pub author_id : i32 , # [serde (rename = "title")] pub title : String , # [serde (rename = "text")] pub text : String , # [serde (rename = "file")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub file : Option < String > } [$ ($ scalar_field) , +] } } ; }
    pub use _partial_unchecked_author_annotation as partial_unchecked;
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: i32,
        #[serde(rename = "author_id")]
        pub author_id: i32,
        #[serde(rename = "title")]
        pub title: String,
        #[serde(rename = "text")]
        pub text: String,
        #[serde(rename = "file")]
        pub file: Option<String>,
        #[serde(rename = "author")]
        pub author: Option<Box<super::author::Data>>,
    }
    impl Data {
        pub fn author(
            &self,
        ) -> Result<&super::author::Data, ::prisma_client_rust::RelationNotFetchedError> {
            self.author
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(author),
                ))
                .map(|v| v.as_ref())
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        Author(super::author::UniqueArgs),
    }
    impl From<WithParam> for ::prisma_client_rust::Selection {
        fn from(val: WithParam) -> Self {
            match val {
                WithParam::Author(args) => {
                    let mut selections = < super :: author :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(author::NAME, None, [], selections)
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(i32),
        IncrementId(i32),
        DecrementId(i32),
        MultiplyId(i32),
        DivideId(i32),
        SetAuthorId(i32),
        IncrementAuthorId(i32),
        DecrementAuthorId(i32),
        MultiplyAuthorId(i32),
        DivideAuthorId(i32),
        SetTitle(String),
        SetText(String),
        SetFile(Option<String>),
        ConnectAuthor(super::author::UniqueWhereParam),
    }
    impl From<SetParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(param: SetParam) -> Self {
            match param {
                SetParam::SetId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetAuthorId(value) => (
                    author_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementAuthorId(value) => (
                    author_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementAuthorId(value) => (
                    author_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyAuthorId(value) => (
                    author_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideAuthorId(value) => (
                    author_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetTitle(value) => (
                    title::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetText(value) => (
                    text::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetFile(value) => (
                    file::NAME.to_string(),
                    value
                        .map(::prisma_client_rust::PrismaValue::String)
                        .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::ConnectAuthor(where_param) => (
                    author::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::author::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UncheckedSetParam {
        Id(i32),
        AuthorId(i32),
        Title(String),
        Text(String),
        File(Option<String>),
    }
    impl From<UncheckedSetParam> for SetParam {
        fn from(param: UncheckedSetParam) -> Self {
            match param {
                UncheckedSetParam::Id(value) => Self::SetId(value),
                UncheckedSetParam::AuthorId(value) => Self::SetAuthorId(value),
                UncheckedSetParam::Title(value) => Self::SetTitle(value),
                UncheckedSetParam::Text(value) => Self::SetText(value),
                UncheckedSetParam::File(value) => Self::SetFile(value),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        AuthorId(::prisma_client_rust::Direction),
        Title(::prisma_client_rust::Direction),
        Text(::prisma_client_rust::Direction),
        File(::prisma_client_rust::Direction),
    }
    impl From<OrderByParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(val: OrderByParam) -> Self {
            match val {
                OrderByParam::Id(direction) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                OrderByParam::AuthorId(direction) => (
                    author_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                OrderByParam::Title(direction) => (
                    title::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                OrderByParam::Text(direction) => (
                    text::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                OrderByParam::File(direction) => (
                    file::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        Id(_prisma::read_filters::IntFilter),
        AuthorId(_prisma::read_filters::IntFilter),
        Title(_prisma::read_filters::StringFilter),
        Text(_prisma::read_filters::StringFilter),
        File(_prisma::read_filters::StringNullableFilter),
        AuthorIs(Vec<super::author::WhereParam>),
        AuthorIsNot(Vec<super::author::WhereParam>),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Id(value) => (id::NAME, value.into()),
                Self::AuthorId(value) => (author_id::NAME, value.into()),
                Self::Title(value) => (title::NAME, value.into()),
                Self::Text(value) => (text::NAME, value.into()),
                Self::File(value) => (file::NAME, value.into()),
                Self::AuthorIs(where_params) => (
                    author::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::AuthorIsNot(where_params) => (
                    author::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value)
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        AuthorIdEquals(i32),
        IdEquals(i32),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::AuthorIdEquals(value) => {
                    Self::AuthorId(_prisma::read_filters::IntFilter::Equals(value))
                }
                UniqueWhereParam::IdEquals(value) => {
                    Self::Id(_prisma::read_filters::IntFilter::Equals(value))
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(id::NAME),
                ::prisma_client_rust::sel(author_id::NAME),
                ::prisma_client_rust::sel(title::NAME),
                ::prisma_client_rust::sel(text::NAME),
                ::prisma_client_rust::sel(file::NAME),
            ]
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            title: String,
            text: String,
            author: super::author::UniqueWhereParam,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.extend([title::set(title), text::set(text), author::connect(author)]);
            Create::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            author_id: i32,
            title: String,
            text: String,
            mut _params: Vec<UncheckedSetParam>,
        ) -> Create<'a> {
            _params.extend([
                author_id::set(author_id),
                title::set(title),
                text::set(text),
            ]);
            Create::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn create_many(
            self,
            data: Vec<(i32, String, String, Vec<SetParam>)>,
        ) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(author_id, title, text, mut _params)| {
                    _params.extend([
                        author_id::set(author_id),
                        title::set(title),
                        text::set(text),
                    ]);
                    _params
                })
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> Update<'a> {
            Update::new(
                self.client,
                _where.into(),
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (title, text, author, mut _params): (
                String,
                String,
                super::author::UniqueWhereParam,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.extend([title::set(title), text::set(text), author::connect(author)]);
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
        pub fn find_raw<T: ::prisma_client_rust::Data>(
            self,
        ) -> ::prisma_client_rust::FindRaw<'a, Types, T> {
            ::prisma_client_rust::FindRaw::new(self.client)
        }
        pub fn aggregate_raw<T: ::prisma_client_rust::Data>(
            self,
        ) -> ::prisma_client_rust::AggregateRaw<'a, Types, T> {
            ::prisma_client_rust::AggregateRaw::new(self.client)
        }
    }
}
pub mod author {
    
    use super::*;
    pub const NAME: &str = "Author";
    pub mod id {
        use super::super::*;
        
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam,
        };
        pub const NAME: &str = "id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Id, {
            fn in_vec(_: Vec<i32>) -> InVec;
            fn not_in_vec(_: Vec<i32>) -> NotInVec;
            fn lt(_: i32) -> Lt;
            fn lte(_: i32) -> Lte;
            fn gt(_: i32) -> Gt;
            fn gte(_: i32) -> Gte;
            fn not(_: i32) -> Not;
        });
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideId(value)
        }
        pub struct Include;
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::Id(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::Id(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod source_id {
        use super::super::*;
        
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "source_id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetSourceId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::SourceId(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::SourceId(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::SourceId(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntFilter,
            SourceId,
            {
                fn in_vec(_: Vec<i32>) -> InVec;
                fn not_in_vec(_: Vec<i32>) -> NotInVec;
                fn lt(_: i32) -> Lt;
                fn lte(_: i32) -> Lte;
                fn gt(_: i32) -> Gt;
                fn gte(_: i32) -> Gte;
                fn not(_: i32) -> Not;
            }
        );
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementSourceId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementSourceId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplySourceId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideSourceId(value)
        }
        pub struct Include;
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::SourceId(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::SourceId(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod remote_id {
        use super::super::*;
        
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "remote_id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetRemoteId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::RemoteId(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::RemoteId(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::RemoteId(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntFilter,
            RemoteId,
            {
                fn in_vec(_: Vec<i32>) -> InVec;
                fn not_in_vec(_: Vec<i32>) -> NotInVec;
                fn lt(_: i32) -> Lt;
                fn lte(_: i32) -> Lte;
                fn gt(_: i32) -> Gt;
                fn gte(_: i32) -> Gte;
                fn not(_: i32) -> Not;
            }
        );
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementRemoteId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementRemoteId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyRemoteId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideRemoteId(value)
        }
        pub struct Include;
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::RemoteId(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::RemoteId(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod first_name {
        use super::super::*;
        
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "first_name";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetFirstName(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::FirstName(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::FirstName(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::FirstName(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            FirstName,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::FirstName(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::FirstName(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod last_name {
        use super::super::*;
        
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "last_name";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetLastName(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::LastName(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::LastName(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::LastName(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            LastName,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::LastName(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::LastName(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod middle_name {
        use super::super::*;
        
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "middle_name";
        pub struct Set(pub Option<String>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetMiddleName(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::MiddleName(v)
            }
        }
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::MiddleName(direction)
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::MiddleName(_prisma::read_filters::StringNullableFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringNullableFilter,
            MiddleName,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: Option<String>) -> Not;
            }
        );
        pub struct Include;
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::MiddleName(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::MiddleName(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod source {
        use super::super::*;
        
        use super::{
            SetParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "source";
        pub struct Fetch(pub source::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<source::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Source(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(source::UniqueArgs::new())
        }
        pub struct Connect(source::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectSource(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: source::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn is(value: Vec<source::WhereParam>) -> WhereParam {
            WhereParam::SourceIs(value)
        }
        pub fn is_not(value: Vec<source::WhereParam>) -> WhereParam {
            WhereParam::SourceIsNot(value)
        }
        pub enum Include {
            Select(Vec<source::SelectParam>),
            Include(Vec<source::IncludeParam>),
            Fetch,
        }
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::Source(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections =
                            <source::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                            );
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <source::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("source", None, [], selections)
            }
            pub fn select(nested_selections: Vec<source::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<source::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<source::SelectParam>),
            Include(Vec<source::IncludeParam>),
            Fetch,
        }
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::Source(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <source::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("source", None, [], selections)
            }
            pub fn select(nested_selections: Vec<source::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<source::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub mod author_annotation {
        use super::super::*;
        
        use super::{
            SetParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "author_annotation";
        pub struct Fetch(pub author_annotation::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<author_annotation::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::AuthorAnnotation(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(author_annotation::UniqueArgs::new())
        }
        pub struct Connect(author_annotation::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectAuthorAnnotation(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: author_annotation::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn disconnect() -> SetParam {
            SetParam::DisconnectAuthorAnnotation
        }
        pub fn is_null() -> WhereParam {
            WhereParam::AuthorAnnotationIsNull
        }
        pub fn is(value: Vec<author_annotation::WhereParam>) -> WhereParam {
            WhereParam::AuthorAnnotationIs(value)
        }
        pub fn is_not(value: Vec<author_annotation::WhereParam>) -> WhereParam {
            WhereParam::AuthorAnnotationIsNot(value)
        }
        pub enum Include {
            Select(Vec<author_annotation::SelectParam>),
            Include(Vec<author_annotation::IncludeParam>),
            Fetch,
        }
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::AuthorAnnotation(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self { Self :: Select (selections) => { selections . into_iter () . map (| s | s . to_selection ()) . collect () } , Self :: Include (selections) => { let mut nested_selections = < author_annotation :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections } , Self :: Fetch => { < author_annotation :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () } } ;
                ::prisma_client_rust::Selection::new("author_annotation", None, [], selections)
            }
            pub fn select(nested_selections: Vec<author_annotation::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<author_annotation::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<author_annotation::SelectParam>),
            Include(Vec<author_annotation::IncludeParam>),
            Fetch,
        }
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::AuthorAnnotation(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self { Self :: Select (selections) => { selections . into_iter () . map (| s | s . to_selection ()) . collect () } , Self :: Include (selections) => { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections } , Self :: Fetch => { < author_annotation :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () } } ;
                ::prisma_client_rust::Selection::new("author_annotation", None, [], selections)
            }
            pub fn select(nested_selections: Vec<author_annotation::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<author_annotation::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub mod book_authors {
        use super::super::*;
        
        use super::{
            SetParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "book_authors";
        pub struct Fetch(pub book_author::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<book_author::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: book_author::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: book_author::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value);
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::BookAuthors(v)
            }
        }
        pub fn fetch(params: Vec<book_author::WhereParam>) -> Fetch {
            Fetch(book_author::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<book_author::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectBookAuthors(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<book_author::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<book_author::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectBookAuthors(params)
        }
        pub fn set(params: Vec<book_author::UniqueWhereParam>) -> SetParam {
            SetParam::SetBookAuthors(params)
        }
        pub fn some(value: Vec<book_author::WhereParam>) -> WhereParam {
            WhereParam::BookAuthorsSome(value)
        }
        pub fn every(value: Vec<book_author::WhereParam>) -> WhereParam {
            WhereParam::BookAuthorsEvery(value)
        }
        pub fn none(value: Vec<book_author::WhereParam>) -> WhereParam {
            WhereParam::BookAuthorsNone(value)
        }
        pub enum Include {
            Select(book_author::ManyArgs, Vec<book_author::SelectParam>),
            Include(book_author::ManyArgs, Vec<book_author::IncludeParam>),
            Fetch(book_author::ManyArgs),
        }
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::BookAuthors(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections = < book_author :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <book_author::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                        ),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: book_author::ManyArgs,
                nested_selections: Vec<book_author::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: book_author::ManyArgs,
                nested_selections: Vec<book_author::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(book_author::ManyArgs, Vec<book_author::SelectParam>),
            Include(book_author::ManyArgs, Vec<book_author::IncludeParam>),
            Fetch(book_author::ManyArgs),
        }
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::BookAuthors(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <book_author::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                        ),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: book_author::ManyArgs,
                nested_selections: Vec<book_author::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: book_author::ManyArgs,
                nested_selections: Vec<book_author::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub mod translations {
        use super::super::*;
        
        use super::{
            SetParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "translations";
        pub struct Fetch(pub translator::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<translator::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: translator::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: translator::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value);
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Translations(v)
            }
        }
        pub fn fetch(params: Vec<translator::WhereParam>) -> Fetch {
            Fetch(translator::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<translator::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectTranslations(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<translator::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<translator::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectTranslations(params)
        }
        pub fn set(params: Vec<translator::UniqueWhereParam>) -> SetParam {
            SetParam::SetTranslations(params)
        }
        pub fn some(value: Vec<translator::WhereParam>) -> WhereParam {
            WhereParam::TranslationsSome(value)
        }
        pub fn every(value: Vec<translator::WhereParam>) -> WhereParam {
            WhereParam::TranslationsEvery(value)
        }
        pub fn none(value: Vec<translator::WhereParam>) -> WhereParam {
            WhereParam::TranslationsNone(value)
        }
        pub enum Include {
            Select(translator::ManyArgs, Vec<translator::SelectParam>),
            Include(translator::ManyArgs, Vec<translator::IncludeParam>),
            Fetch(translator::ManyArgs),
        }
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::Translations(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections = < translator :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <translator::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                        ),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: translator::ManyArgs,
                nested_selections: Vec<translator::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: translator::ManyArgs,
                nested_selections: Vec<translator::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(translator::ManyArgs, Vec<translator::SelectParam>),
            Include(translator::ManyArgs, Vec<translator::IncludeParam>),
            Fetch(translator::ManyArgs),
        }
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::Translations(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <translator::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                        ),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: translator::ManyArgs,
                nested_selections: Vec<translator::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: translator::ManyArgs,
                nested_selections: Vec<translator::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub fn source_id_remote_id<T: From<UniqueWhereParam>>(source_id: i32, remote_id: i32) -> T {
        UniqueWhereParam::SourceIdRemoteIdEquals(source_id, remote_id).into()
    }
    pub fn create(
        remote_id: i32,
        first_name: String,
        last_name: String,
        source: super::source::UniqueWhereParam,
        _params: Vec<SetParam>,
    ) -> (
        i32,
        String,
        String,
        super::source::UniqueWhereParam,
        Vec<SetParam>,
    ) {
        (remote_id, first_name, last_name, source, _params)
    }
    pub fn create_unchecked(
        source_id: i32,
        remote_id: i32,
        first_name: String,
        last_name: String,
        _params: Vec<SetParam>,
    ) -> (i32, i32, String, String, Vec<SetParam>) {
        (source_id, remote_id, first_name, last_name, _params)
    }
    #[macro_export]
    macro_rules ! _select_author { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $crate :: prisma :: author :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = $crate :: prisma :: author :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: author :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: author :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: author :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: author :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , source_id , remote_id , first_name , last_name , middle_name , source , author_annotation , book_authors , translations } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : crate :: prisma :: author :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: author :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: author :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: author :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: author :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: author :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "source_id" , "remote_id" , "first_name" , "last_name" , "middle_name" , "source" , "author_annotation" , "book_authors" , "translations"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: author :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i32 } ; (@ field_type ; source_id) => { i32 } ; (@ field_type ; remote_id) => { i32 } ; (@ field_type ; first_name) => { String } ; (@ field_type ; last_name) => { String } ; (@ field_type ; middle_name) => { Option < String > } ; (@ field_type ; source : $ selection_mode : ident { $ ($ selections : tt) + }) => { source :: Data } ; (@ field_type ; source) => { crate :: prisma :: source :: Data } ; (@ field_type ; author_annotation : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < author_annotation :: Data > } ; (@ field_type ; author_annotation) => { Option < crate :: prisma :: author_annotation :: Data > } ; (@ field_type ; book_authors : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < book_authors :: Data > } ; (@ field_type ; book_authors) => { Vec < crate :: prisma :: book_author :: Data > } ; (@ field_type ; translations : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < translations :: Data > } ; (@ field_type ; translations) => { Vec < crate :: prisma :: translator :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Author" , available relations are "id, source_id, remote_id, first_name, last_name, middle_name, source, author_annotation, book_authors, translations")) } ; (@ field_module ; source : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: source :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; author_annotation : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: author_annotation :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; book_authors : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: book_author :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; translations : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: translator :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: author :: SelectParam > :: into (crate :: prisma :: author :: id :: Select) } ; (@ selection_field_to_selection_param ; source_id) => { Into :: < crate :: prisma :: author :: SelectParam > :: into (crate :: prisma :: author :: source_id :: Select) } ; (@ selection_field_to_selection_param ; remote_id) => { Into :: < crate :: prisma :: author :: SelectParam > :: into (crate :: prisma :: author :: remote_id :: Select) } ; (@ selection_field_to_selection_param ; first_name) => { Into :: < crate :: prisma :: author :: SelectParam > :: into (crate :: prisma :: author :: first_name :: Select) } ; (@ selection_field_to_selection_param ; last_name) => { Into :: < crate :: prisma :: author :: SelectParam > :: into (crate :: prisma :: author :: last_name :: Select) } ; (@ selection_field_to_selection_param ; middle_name) => { Into :: < crate :: prisma :: author :: SelectParam > :: into (crate :: prisma :: author :: middle_name :: Select) } ; (@ selection_field_to_selection_param ; source $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: author :: SelectParam > :: into (crate :: prisma :: author :: source :: Select :: $ selection_mode (crate :: prisma :: source :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; source $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: author :: SelectParam > :: into (crate :: prisma :: author :: source :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; author_annotation $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: author :: SelectParam > :: into (crate :: prisma :: author :: author_annotation :: Select :: $ selection_mode (crate :: prisma :: author_annotation :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; author_annotation $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: author :: SelectParam > :: into (crate :: prisma :: author :: author_annotation :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; book_authors $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: author :: SelectParam > :: into (crate :: prisma :: author :: book_authors :: Select :: $ selection_mode (crate :: prisma :: book_author :: ManyArgs :: new (crate :: prisma :: book_author :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: book_author :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; book_authors $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: author :: SelectParam > :: into (crate :: prisma :: author :: book_authors :: Select :: Fetch (crate :: prisma :: book_author :: ManyArgs :: new (crate :: prisma :: book_author :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; translations $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: author :: SelectParam > :: into (crate :: prisma :: author :: translations :: Select :: $ selection_mode (crate :: prisma :: translator :: ManyArgs :: new (crate :: prisma :: translator :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: translator :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; translations $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: author :: SelectParam > :: into (crate :: prisma :: author :: translations :: Select :: Fetch (crate :: prisma :: translator :: ManyArgs :: new (crate :: prisma :: translator :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: author :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; source_id) => { "source_id" } ; (@ field_serde_name ; remote_id) => { "remote_id" } ; (@ field_serde_name ; first_name) => { "first_name" } ; (@ field_serde_name ; last_name) => { "last_name" } ; (@ field_serde_name ; middle_name) => { "middle_name" } ; (@ field_serde_name ; source) => { "source" } ; (@ field_serde_name ; author_annotation) => { "author_annotation" } ; (@ field_serde_name ; book_authors) => { "book_authors" } ; (@ field_serde_name ; translations) => { "translations" } ; }
    pub use _select_author as select;
    pub enum SelectParam {
        Id(id::Select),
        SourceId(source_id::Select),
        RemoteId(remote_id::Select),
        FirstName(first_name::Select),
        LastName(last_name::Select),
        MiddleName(middle_name::Select),
        Source(source::Select),
        AuthorAnnotation(author_annotation::Select),
        BookAuthors(book_authors::Select),
        Translations(translations::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::SourceId(data) => data.to_selection(),
                Self::RemoteId(data) => data.to_selection(),
                Self::FirstName(data) => data.to_selection(),
                Self::LastName(data) => data.to_selection(),
                Self::MiddleName(data) => data.to_selection(),
                Self::Source(data) => data.to_selection(),
                Self::AuthorAnnotation(data) => data.to_selection(),
                Self::BookAuthors(data) => data.to_selection(),
                Self::Translations(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_author { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $crate :: prisma :: author :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = $crate :: prisma :: author :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: author :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: author :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: author :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: author :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: author :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: author :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { source , author_annotation , book_authors , translations } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : i32 , pub source_id : i32 , pub remote_id : i32 , pub first_name : String , pub last_name : String , pub middle_name : Option < String > , $ (pub $ field : crate :: prisma :: author :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (source_id) , stringify ! (remote_id) , stringify ! (first_name) , stringify ! (last_name) , stringify ! (middle_name)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: author :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: author :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: author :: source_id :: NAME , & self . source_id) ? ; state . serialize_field (crate :: prisma :: author :: remote_id :: NAME , & self . remote_id) ? ; state . serialize_field (crate :: prisma :: author :: first_name :: NAME , & self . first_name) ? ; state . serialize_field (crate :: prisma :: author :: last_name :: NAME , & self . last_name) ? ; state . serialize_field (crate :: prisma :: author :: middle_name :: NAME , & self . middle_name) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , source_id , remote_id , first_name , last_name , middle_name } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: author :: $ field :: NAME) , + , crate :: prisma :: author :: id :: NAME , crate :: prisma :: author :: source_id :: NAME , crate :: prisma :: author :: remote_id :: NAME , crate :: prisma :: author :: first_name :: NAME , crate :: prisma :: author :: last_name :: NAME , crate :: prisma :: author :: middle_name :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: author :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: author :: id :: NAME => Ok (Field :: id) , crate :: prisma :: author :: source_id :: NAME => Ok (Field :: source_id) , crate :: prisma :: author :: remote_id :: NAME => Ok (Field :: remote_id) , crate :: prisma :: author :: first_name :: NAME => Ok (Field :: first_name) , crate :: prisma :: author :: last_name :: NAME => Ok (Field :: last_name) , crate :: prisma :: author :: middle_name :: NAME => Ok (Field :: middle_name) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut source_id = None ; let mut remote_id = None ; let mut first_name = None ; let mut last_name = None ; let mut middle_name = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: author :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: source_id => { if source_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: author :: source_id :: NAME)) ; } source_id = Some (map . next_value () ?) ; } Field :: remote_id => { if remote_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: author :: remote_id :: NAME)) ; } remote_id = Some (map . next_value () ?) ; } Field :: first_name => { if first_name . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: author :: first_name :: NAME)) ; } first_name = Some (map . next_value () ?) ; } Field :: last_name => { if last_name . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: author :: last_name :: NAME)) ; } last_name = Some (map . next_value () ?) ; } Field :: middle_name => { if middle_name . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: author :: middle_name :: NAME)) ; } middle_name = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: author :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: author :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: author :: id :: NAME)) ? ; let source_id = source_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: author :: source_id :: NAME)) ? ; let remote_id = remote_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: author :: remote_id :: NAME)) ? ; let first_name = first_name . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: author :: first_name :: NAME)) ? ; let last_name = last_name . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: author :: last_name :: NAME)) ? ; let middle_name = middle_name . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: author :: middle_name :: NAME)) ? ; Ok (Data { id , source_id , remote_id , first_name , last_name , middle_name , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "source_id" , "remote_id" , "first_name" , "last_name" , "middle_name" , "source" , "author_annotation" , "book_authors" , "translations"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: author :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; source : $ selection_mode : ident { $ ($ selections : tt) + }) => { source :: Data } ; (@ field_type ; source) => { crate :: prisma :: source :: Data } ; (@ field_type ; author_annotation : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < author_annotation :: Data > } ; (@ field_type ; author_annotation) => { Option < crate :: prisma :: author_annotation :: Data > } ; (@ field_type ; book_authors : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < book_authors :: Data > } ; (@ field_type ; book_authors) => { Vec < crate :: prisma :: book_author :: Data > } ; (@ field_type ; translations : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < translations :: Data > } ; (@ field_type ; translations) => { Vec < crate :: prisma :: translator :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Author" , available relations are "source, author_annotation, book_authors, translations")) } ; (@ field_module ; source : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: source :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; author_annotation : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: author_annotation :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; book_authors : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: book_author :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; translations : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: translator :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; source $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: author :: IncludeParam > :: into (crate :: prisma :: author :: source :: Include :: $ selection_mode (crate :: prisma :: source :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; source $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: author :: IncludeParam > :: into (crate :: prisma :: author :: source :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; author_annotation $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: author :: IncludeParam > :: into (crate :: prisma :: author :: author_annotation :: Include :: $ selection_mode (crate :: prisma :: author_annotation :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; author_annotation $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: author :: IncludeParam > :: into (crate :: prisma :: author :: author_annotation :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; book_authors $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: author :: IncludeParam > :: into (crate :: prisma :: author :: book_authors :: Include :: $ selection_mode (crate :: prisma :: book_author :: ManyArgs :: new (crate :: prisma :: book_author :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: book_author :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; book_authors $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: author :: IncludeParam > :: into (crate :: prisma :: author :: book_authors :: Include :: Fetch (crate :: prisma :: book_author :: ManyArgs :: new (crate :: prisma :: book_author :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; translations $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: author :: IncludeParam > :: into (crate :: prisma :: author :: translations :: Include :: $ selection_mode (crate :: prisma :: translator :: ManyArgs :: new (crate :: prisma :: translator :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: translator :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; translations $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: author :: IncludeParam > :: into (crate :: prisma :: author :: translations :: Include :: Fetch (crate :: prisma :: translator :: ManyArgs :: new (crate :: prisma :: translator :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: author :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; source_id) => { "source_id" } ; (@ field_serde_name ; remote_id) => { "remote_id" } ; (@ field_serde_name ; first_name) => { "first_name" } ; (@ field_serde_name ; last_name) => { "last_name" } ; (@ field_serde_name ; middle_name) => { "middle_name" } ; (@ field_serde_name ; source) => { "source" } ; (@ field_serde_name ; author_annotation) => { "author_annotation" } ; (@ field_serde_name ; book_authors) => { "book_authors" } ; (@ field_serde_name ; translations) => { "translations" } ; }
    pub use _include_author as include;
    pub enum IncludeParam {
        Id(id::Include),
        SourceId(source_id::Include),
        RemoteId(remote_id::Include),
        FirstName(first_name::Include),
        LastName(last_name::Include),
        MiddleName(middle_name::Include),
        Source(source::Include),
        AuthorAnnotation(author_annotation::Include),
        BookAuthors(book_authors::Include),
        Translations(translations::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::SourceId(data) => data.to_selection(),
                Self::RemoteId(data) => data.to_selection(),
                Self::FirstName(data) => data.to_selection(),
                Self::LastName(data) => data.to_selection(),
                Self::MiddleName(data) => data.to_selection(),
                Self::Source(data) => data.to_selection(),
                Self::AuthorAnnotation(data) => data.to_selection(),
                Self::BookAuthors(data) => data.to_selection(),
                Self::Translations(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _partial_unchecked_author { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { $crate :: prisma :: author struct $ struct_name { # [serde (rename = "id")] pub id : i32 , # [serde (rename = "source_id")] pub source_id : i32 , # [serde (rename = "remote_id")] pub remote_id : i32 , # [serde (rename = "first_name")] pub first_name : String , # [serde (rename = "last_name")] pub last_name : String , # [serde (rename = "middle_name")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub middle_name : Option < String > } [$ ($ scalar_field) , +] } } ; }
    pub use _partial_unchecked_author as partial_unchecked;
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: i32,
        #[serde(rename = "source_id")]
        pub source_id: i32,
        #[serde(rename = "remote_id")]
        pub remote_id: i32,
        #[serde(rename = "first_name")]
        pub first_name: String,
        #[serde(rename = "last_name")]
        pub last_name: String,
        #[serde(rename = "middle_name")]
        pub middle_name: Option<String>,
        #[serde(rename = "source")]
        pub source: Option<Box<super::source::Data>>,
        #[serde(
            rename = "author_annotation",
            default,
            skip_serializing_if = "Option::is_none",
            with = "prisma_client_rust::serde::double_option"
        )]
        pub author_annotation: Option<Option<Box<super::author_annotation::Data>>>,
        #[serde(rename = "book_authors")]
        pub book_authors: Option<Vec<super::book_author::Data>>,
        #[serde(rename = "translations")]
        pub translations: Option<Vec<super::translator::Data>>,
    }
    impl Data {
        pub fn source(
            &self,
        ) -> Result<&super::source::Data, ::prisma_client_rust::RelationNotFetchedError> {
            self.source
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(source),
                ))
                .map(|v| v.as_ref())
        }
        pub fn author_annotation(
            &self,
        ) -> Result<
            Option<&super::author_annotation::Data>,
            ::prisma_client_rust::RelationNotFetchedError,
        > {
            self.author_annotation
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(author_annotation),
                ))
                .map(|v| v.as_ref().map(|v| v.as_ref()))
        }
        pub fn book_authors(
            &self,
        ) -> Result<&Vec<super::book_author::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.book_authors
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(book_authors),
                ))
        }
        pub fn translations(
            &self,
        ) -> Result<&Vec<super::translator::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.translations
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(translations),
                ))
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        Source(super::source::UniqueArgs),
        AuthorAnnotation(super::author_annotation::UniqueArgs),
        BookAuthors(super::book_author::ManyArgs),
        Translations(super::translator::ManyArgs),
    }
    impl From<WithParam> for ::prisma_client_rust::Selection {
        fn from(val: WithParam) -> Self {
            match val {
                WithParam::Source(args) => {
                    let mut selections = < super :: source :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(source::NAME, None, [], selections)
                }
                WithParam::AuthorAnnotation(args) => {
                    let mut selections = < super :: author_annotation :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(
                        author_annotation::NAME,
                        None,
                        [],
                        selections,
                    )
                }
                WithParam::BookAuthors(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections . extend (< super :: book_author :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
                    ::prisma_client_rust::Selection::new(
                        book_authors::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
                WithParam::Translations(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections . extend (< super :: translator :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
                    ::prisma_client_rust::Selection::new(
                        translations::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(i32),
        IncrementId(i32),
        DecrementId(i32),
        MultiplyId(i32),
        DivideId(i32),
        SetSourceId(i32),
        IncrementSourceId(i32),
        DecrementSourceId(i32),
        MultiplySourceId(i32),
        DivideSourceId(i32),
        SetRemoteId(i32),
        IncrementRemoteId(i32),
        DecrementRemoteId(i32),
        MultiplyRemoteId(i32),
        DivideRemoteId(i32),
        SetFirstName(String),
        SetLastName(String),
        SetMiddleName(Option<String>),
        ConnectSource(super::source::UniqueWhereParam),
        ConnectAuthorAnnotation(super::author_annotation::UniqueWhereParam),
        DisconnectAuthorAnnotation,
        ConnectBookAuthors(Vec<super::book_author::UniqueWhereParam>),
        DisconnectBookAuthors(Vec<super::book_author::UniqueWhereParam>),
        SetBookAuthors(Vec<super::book_author::UniqueWhereParam>),
        ConnectTranslations(Vec<super::translator::UniqueWhereParam>),
        DisconnectTranslations(Vec<super::translator::UniqueWhereParam>),
        SetTranslations(Vec<super::translator::UniqueWhereParam>),
    }
    impl From<SetParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(param: SetParam) -> Self {
            match param {
                SetParam::SetId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetSourceId(value) => (
                    source_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementSourceId(value) => (
                    source_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementSourceId(value) => (
                    source_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplySourceId(value) => (
                    source_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideSourceId(value) => (
                    source_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetRemoteId(value) => (
                    remote_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementRemoteId(value) => (
                    remote_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementRemoteId(value) => (
                    remote_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyRemoteId(value) => (
                    remote_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideRemoteId(value) => (
                    remote_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetFirstName(value) => (
                    first_name::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetLastName(value) => (
                    last_name::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetMiddleName(value) => (
                    middle_name::NAME.to_string(),
                    value
                        .map(::prisma_client_rust::PrismaValue::String)
                        .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::ConnectSource(where_param) => (
                    source::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::source::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectAuthorAnnotation(where_param) => (
                    author_annotation::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::author_annotation::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectAuthorAnnotation => (
                    author_annotation::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::Boolean(true),
                    )]),
                ),
                SetParam::ConnectBookAuthors(where_params) => (
                    book_authors::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::book_author::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectBookAuthors(where_params) => (
                    book_authors::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::book_author::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetBookAuthors(where_params) => (
                    book_authors::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::book_author::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectTranslations(where_params) => (
                    translations::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::translator::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectTranslations(where_params) => (
                    translations::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::translator::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetTranslations(where_params) => (
                    translations::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::translator::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UncheckedSetParam {
        Id(i32),
        SourceId(i32),
        RemoteId(i32),
        FirstName(String),
        LastName(String),
        MiddleName(Option<String>),
    }
    impl From<UncheckedSetParam> for SetParam {
        fn from(param: UncheckedSetParam) -> Self {
            match param {
                UncheckedSetParam::Id(value) => Self::SetId(value),
                UncheckedSetParam::SourceId(value) => Self::SetSourceId(value),
                UncheckedSetParam::RemoteId(value) => Self::SetRemoteId(value),
                UncheckedSetParam::FirstName(value) => Self::SetFirstName(value),
                UncheckedSetParam::LastName(value) => Self::SetLastName(value),
                UncheckedSetParam::MiddleName(value) => Self::SetMiddleName(value),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        SourceId(::prisma_client_rust::Direction),
        RemoteId(::prisma_client_rust::Direction),
        FirstName(::prisma_client_rust::Direction),
        LastName(::prisma_client_rust::Direction),
        MiddleName(::prisma_client_rust::Direction),
    }
    impl From<OrderByParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(val: OrderByParam) -> Self {
            match val {
                OrderByParam::Id(direction) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                OrderByParam::SourceId(direction) => (
                    source_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                OrderByParam::RemoteId(direction) => (
                    remote_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                OrderByParam::FirstName(direction) => (
                    first_name::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                OrderByParam::LastName(direction) => (
                    last_name::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                OrderByParam::MiddleName(direction) => (
                    middle_name::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        SourceIdRemoteIdEquals(i32, i32),
        Id(_prisma::read_filters::IntFilter),
        SourceId(_prisma::read_filters::IntFilter),
        RemoteId(_prisma::read_filters::IntFilter),
        FirstName(_prisma::read_filters::StringFilter),
        LastName(_prisma::read_filters::StringFilter),
        MiddleName(_prisma::read_filters::StringNullableFilter),
        SourceIs(Vec<super::source::WhereParam>),
        SourceIsNot(Vec<super::source::WhereParam>),
        AuthorAnnotationIsNull,
        AuthorAnnotationIs(Vec<super::author_annotation::WhereParam>),
        AuthorAnnotationIsNot(Vec<super::author_annotation::WhereParam>),
        BookAuthorsSome(Vec<super::book_author::WhereParam>),
        BookAuthorsEvery(Vec<super::book_author::WhereParam>),
        BookAuthorsNone(Vec<super::book_author::WhereParam>),
        TranslationsSome(Vec<super::translator::WhereParam>),
        TranslationsEvery(Vec<super::translator::WhereParam>),
        TranslationsNone(Vec<super::translator::WhereParam>),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::SourceIdRemoteIdEquals(source_id, remote_id) => (
                    "source_id_remote_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![
                        (
                            source_id::NAME.to_string(),
                            ::prisma_client_rust::PrismaValue::Int(source_id as i64),
                        ),
                        (
                            remote_id::NAME.to_string(),
                            ::prisma_client_rust::PrismaValue::Int(remote_id as i64),
                        ),
                    ]),
                ),
                Self::Id(value) => (id::NAME, value.into()),
                Self::SourceId(value) => (source_id::NAME, value.into()),
                Self::RemoteId(value) => (remote_id::NAME, value.into()),
                Self::FirstName(value) => (first_name::NAME, value.into()),
                Self::LastName(value) => (last_name::NAME, value.into()),
                Self::MiddleName(value) => (middle_name::NAME, value.into()),
                Self::SourceIs(where_params) => (
                    source::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::SourceIsNot(where_params) => (
                    source::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::AuthorAnnotationIsNull => (
                    author_annotation::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Value(
                        ::prisma_client_rust::PrismaValue::Null,
                    ),
                ),
                Self::AuthorAnnotationIs(where_params) => (
                    author_annotation::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::AuthorAnnotationIsNot(where_params) => (
                    author_annotation::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::BookAuthorsSome(where_params) => (
                    book_authors::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::BookAuthorsEvery(where_params) => (
                    book_authors::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::BookAuthorsNone(where_params) => (
                    book_authors::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::TranslationsSome(where_params) => (
                    translations::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::TranslationsEvery(where_params) => (
                    translations::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::TranslationsNone(where_params) => (
                    translations::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value)
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        SourceIdRemoteIdEquals(i32, i32),
        IdEquals(i32),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::SourceIdRemoteIdEquals(source_id, remote_id) => {
                    Self::SourceIdRemoteIdEquals(source_id, remote_id)
                }
                UniqueWhereParam::IdEquals(value) => {
                    Self::Id(_prisma::read_filters::IntFilter::Equals(value))
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(id::NAME),
                ::prisma_client_rust::sel(source_id::NAME),
                ::prisma_client_rust::sel(remote_id::NAME),
                ::prisma_client_rust::sel(first_name::NAME),
                ::prisma_client_rust::sel(last_name::NAME),
                ::prisma_client_rust::sel(middle_name::NAME),
            ]
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            remote_id: i32,
            first_name: String,
            last_name: String,
            source: super::source::UniqueWhereParam,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.extend([
                remote_id::set(remote_id),
                first_name::set(first_name),
                last_name::set(last_name),
                source::connect(source),
            ]);
            Create::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            source_id: i32,
            remote_id: i32,
            first_name: String,
            last_name: String,
            mut _params: Vec<UncheckedSetParam>,
        ) -> Create<'a> {
            _params.extend([
                source_id::set(source_id),
                remote_id::set(remote_id),
                first_name::set(first_name),
                last_name::set(last_name),
            ]);
            Create::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn create_many(
            self,
            data: Vec<(i32, i32, String, String, Vec<SetParam>)>,
        ) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(
                    |(source_id, remote_id, first_name, last_name, mut _params)| {
                        _params.extend([
                            source_id::set(source_id),
                            remote_id::set(remote_id),
                            first_name::set(first_name),
                            last_name::set(last_name),
                        ]);
                        _params
                    },
                )
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> Update<'a> {
            Update::new(
                self.client,
                _where.into(),
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (remote_id, first_name, last_name, source, mut _params): (
                i32,
                String,
                String,
                super::source::UniqueWhereParam,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.extend([
                remote_id::set(remote_id),
                first_name::set(first_name),
                last_name::set(last_name),
                source::connect(source),
            ]);
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
        pub fn find_raw<T: ::prisma_client_rust::Data>(
            self,
        ) -> ::prisma_client_rust::FindRaw<'a, Types, T> {
            ::prisma_client_rust::FindRaw::new(self.client)
        }
        pub fn aggregate_raw<T: ::prisma_client_rust::Data>(
            self,
        ) -> ::prisma_client_rust::AggregateRaw<'a, Types, T> {
            ::prisma_client_rust::AggregateRaw::new(self.client)
        }
    }
}
pub mod book_annotation {
    
    use super::*;
    pub const NAME: &str = "BookAnnotation";
    pub mod id {
        use super::super::*;
        
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam,
        };
        pub const NAME: &str = "id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Id, {
            fn in_vec(_: Vec<i32>) -> InVec;
            fn not_in_vec(_: Vec<i32>) -> NotInVec;
            fn lt(_: i32) -> Lt;
            fn lte(_: i32) -> Lte;
            fn gt(_: i32) -> Gt;
            fn gte(_: i32) -> Gte;
            fn not(_: i32) -> Not;
        });
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideId(value)
        }
        pub struct Include;
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::Id(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::Id(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod book_id {
        use super::super::*;
        
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam,
        };
        pub const NAME: &str = "book_id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetBookId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::BookId(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::BookId(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
            UniqueWhereParam::BookIdEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, BookId, {
            fn in_vec(_: Vec<i32>) -> InVec;
            fn not_in_vec(_: Vec<i32>) -> NotInVec;
            fn lt(_: i32) -> Lt;
            fn lte(_: i32) -> Lte;
            fn gt(_: i32) -> Gt;
            fn gte(_: i32) -> Gte;
            fn not(_: i32) -> Not;
        });
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementBookId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementBookId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyBookId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideBookId(value)
        }
        pub struct Include;
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::BookId(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::BookId(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod title {
        use super::super::*;
        
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "title";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetTitle(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Title(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Title(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::Title(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            Title,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::Title(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::Title(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod text {
        use super::super::*;
        
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "text";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetText(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Text(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Text(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::Text(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::StringFilter, Text, {
            fn in_vec(_: Vec<String>) -> InVec;
            fn not_in_vec(_: Vec<String>) -> NotInVec;
            fn lt(_: String) -> Lt;
            fn lte(_: String) -> Lte;
            fn gt(_: String) -> Gt;
            fn gte(_: String) -> Gte;
            fn contains(_: String) -> Contains;
            fn starts_with(_: String) -> StartsWith;
            fn ends_with(_: String) -> EndsWith;
            fn mode(_: super::super::QueryMode) -> Mode;
            fn not(_: String) -> Not;
        });
        pub struct Include;
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::Text(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::Text(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod file {
        use super::super::*;
        
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "file";
        pub struct Set(pub Option<String>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetFile(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::File(v)
            }
        }
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::File(direction)
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::File(_prisma::read_filters::StringNullableFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringNullableFilter,
            File,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: Option<String>) -> Not;
            }
        );
        pub struct Include;
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::File(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::File(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod book {
        use super::super::*;
        
        use super::{
            SetParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "book";
        pub struct Fetch(pub book::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<book::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Book(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(book::UniqueArgs::new())
        }
        pub struct Connect(book::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectBook(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: book::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn is(value: Vec<book::WhereParam>) -> WhereParam {
            WhereParam::BookIs(value)
        }
        pub fn is_not(value: Vec<book::WhereParam>) -> WhereParam {
            WhereParam::BookIsNot(value)
        }
        pub enum Include {
            Select(Vec<book::SelectParam>),
            Include(Vec<book::IncludeParam>),
            Fetch,
        }
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::Book(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections =
                            <book::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <book::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("book", None, [], selections)
            }
            pub fn select(nested_selections: Vec<book::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<book::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<book::SelectParam>),
            Include(Vec<book::IncludeParam>),
            Fetch,
        }
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::Book(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <book::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("book", None, [], selections)
            }
            pub fn select(nested_selections: Vec<book::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<book::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub fn create(
        title: String,
        text: String,
        book: super::book::UniqueWhereParam,
        _params: Vec<SetParam>,
    ) -> (String, String, super::book::UniqueWhereParam, Vec<SetParam>) {
        (title, text, book, _params)
    }
    pub fn create_unchecked(
        book_id: i32,
        title: String,
        text: String,
        _params: Vec<SetParam>,
    ) -> (i32, String, String, Vec<SetParam>) {
        (book_id, title, text, _params)
    }
    #[macro_export]
    macro_rules ! _select_book_annotation { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $crate :: prisma :: book_annotation :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = $crate :: prisma :: book_annotation :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: book_annotation :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: book_annotation :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: book_annotation :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: book_annotation :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , book_id , title , text , file , book } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : crate :: prisma :: book_annotation :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: book_annotation :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: book_annotation :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: book_annotation :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: book_annotation :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: book_annotation :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "book_id" , "title" , "text" , "file" , "book"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: book_annotation :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i32 } ; (@ field_type ; book_id) => { i32 } ; (@ field_type ; title) => { String } ; (@ field_type ; text) => { String } ; (@ field_type ; file) => { Option < String > } ; (@ field_type ; book : $ selection_mode : ident { $ ($ selections : tt) + }) => { book :: Data } ; (@ field_type ; book) => { crate :: prisma :: book :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "BookAnnotation" , available relations are "id, book_id, title, text, file, book")) } ; (@ field_module ; book : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: book :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: book_annotation :: SelectParam > :: into (crate :: prisma :: book_annotation :: id :: Select) } ; (@ selection_field_to_selection_param ; book_id) => { Into :: < crate :: prisma :: book_annotation :: SelectParam > :: into (crate :: prisma :: book_annotation :: book_id :: Select) } ; (@ selection_field_to_selection_param ; title) => { Into :: < crate :: prisma :: book_annotation :: SelectParam > :: into (crate :: prisma :: book_annotation :: title :: Select) } ; (@ selection_field_to_selection_param ; text) => { Into :: < crate :: prisma :: book_annotation :: SelectParam > :: into (crate :: prisma :: book_annotation :: text :: Select) } ; (@ selection_field_to_selection_param ; file) => { Into :: < crate :: prisma :: book_annotation :: SelectParam > :: into (crate :: prisma :: book_annotation :: file :: Select) } ; (@ selection_field_to_selection_param ; book $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: book_annotation :: SelectParam > :: into (crate :: prisma :: book_annotation :: book :: Select :: $ selection_mode (crate :: prisma :: book :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; book $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: book_annotation :: SelectParam > :: into (crate :: prisma :: book_annotation :: book :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: book_annotation :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; book_id) => { "book_id" } ; (@ field_serde_name ; title) => { "title" } ; (@ field_serde_name ; text) => { "text" } ; (@ field_serde_name ; file) => { "file" } ; (@ field_serde_name ; book) => { "book" } ; }
    pub use _select_book_annotation as select;
    pub enum SelectParam {
        Id(id::Select),
        BookId(book_id::Select),
        Title(title::Select),
        Text(text::Select),
        File(file::Select),
        Book(book::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::BookId(data) => data.to_selection(),
                Self::Title(data) => data.to_selection(),
                Self::Text(data) => data.to_selection(),
                Self::File(data) => data.to_selection(),
                Self::Book(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_book_annotation { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $crate :: prisma :: book_annotation :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = $crate :: prisma :: book_annotation :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: book_annotation :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: book_annotation :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: book_annotation :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: book_annotation :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: book_annotation :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: book_annotation :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { book } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : i32 , pub book_id : i32 , pub title : String , pub text : String , pub file : Option < String > , $ (pub $ field : crate :: prisma :: book_annotation :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (book_id) , stringify ! (title) , stringify ! (text) , stringify ! (file)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: book_annotation :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: book_annotation :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: book_annotation :: book_id :: NAME , & self . book_id) ? ; state . serialize_field (crate :: prisma :: book_annotation :: title :: NAME , & self . title) ? ; state . serialize_field (crate :: prisma :: book_annotation :: text :: NAME , & self . text) ? ; state . serialize_field (crate :: prisma :: book_annotation :: file :: NAME , & self . file) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , book_id , title , text , file } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: book_annotation :: $ field :: NAME) , + , crate :: prisma :: book_annotation :: id :: NAME , crate :: prisma :: book_annotation :: book_id :: NAME , crate :: prisma :: book_annotation :: title :: NAME , crate :: prisma :: book_annotation :: text :: NAME , crate :: prisma :: book_annotation :: file :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: book_annotation :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: book_annotation :: id :: NAME => Ok (Field :: id) , crate :: prisma :: book_annotation :: book_id :: NAME => Ok (Field :: book_id) , crate :: prisma :: book_annotation :: title :: NAME => Ok (Field :: title) , crate :: prisma :: book_annotation :: text :: NAME => Ok (Field :: text) , crate :: prisma :: book_annotation :: file :: NAME => Ok (Field :: file) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut book_id = None ; let mut title = None ; let mut text = None ; let mut file = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: book_annotation :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: book_id => { if book_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: book_annotation :: book_id :: NAME)) ; } book_id = Some (map . next_value () ?) ; } Field :: title => { if title . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: book_annotation :: title :: NAME)) ; } title = Some (map . next_value () ?) ; } Field :: text => { if text . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: book_annotation :: text :: NAME)) ; } text = Some (map . next_value () ?) ; } Field :: file => { if file . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: book_annotation :: file :: NAME)) ; } file = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: book_annotation :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: book_annotation :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: book_annotation :: id :: NAME)) ? ; let book_id = book_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: book_annotation :: book_id :: NAME)) ? ; let title = title . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: book_annotation :: title :: NAME)) ? ; let text = text . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: book_annotation :: text :: NAME)) ? ; let file = file . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: book_annotation :: file :: NAME)) ? ; Ok (Data { id , book_id , title , text , file , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "book_id" , "title" , "text" , "file" , "book"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: book_annotation :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; book : $ selection_mode : ident { $ ($ selections : tt) + }) => { book :: Data } ; (@ field_type ; book) => { crate :: prisma :: book :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "BookAnnotation" , available relations are "book")) } ; (@ field_module ; book : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: book :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; book $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: book_annotation :: IncludeParam > :: into (crate :: prisma :: book_annotation :: book :: Include :: $ selection_mode (crate :: prisma :: book :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; book $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: book_annotation :: IncludeParam > :: into (crate :: prisma :: book_annotation :: book :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: book_annotation :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; book_id) => { "book_id" } ; (@ field_serde_name ; title) => { "title" } ; (@ field_serde_name ; text) => { "text" } ; (@ field_serde_name ; file) => { "file" } ; (@ field_serde_name ; book) => { "book" } ; }
    pub use _include_book_annotation as include;
    pub enum IncludeParam {
        Id(id::Include),
        BookId(book_id::Include),
        Title(title::Include),
        Text(text::Include),
        File(file::Include),
        Book(book::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::BookId(data) => data.to_selection(),
                Self::Title(data) => data.to_selection(),
                Self::Text(data) => data.to_selection(),
                Self::File(data) => data.to_selection(),
                Self::Book(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _partial_unchecked_book_annotation { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { $crate :: prisma :: book_annotation struct $ struct_name { # [serde (rename = "id")] pub id : i32 , # [serde (rename = "book_id")] pub book_id : i32 , # [serde (rename = "title")] pub title : String , # [serde (rename = "text")] pub text : String , # [serde (rename = "file")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub file : Option < String > } [$ ($ scalar_field) , +] } } ; }
    pub use _partial_unchecked_book_annotation as partial_unchecked;
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: i32,
        #[serde(rename = "book_id")]
        pub book_id: i32,
        #[serde(rename = "title")]
        pub title: String,
        #[serde(rename = "text")]
        pub text: String,
        #[serde(rename = "file")]
        pub file: Option<String>,
        #[serde(rename = "book")]
        pub book: Option<Box<super::book::Data>>,
    }
    impl Data {
        pub fn book(
            &self,
        ) -> Result<&super::book::Data, ::prisma_client_rust::RelationNotFetchedError> {
            self.book
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(book),
                ))
                .map(|v| v.as_ref())
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        Book(super::book::UniqueArgs),
    }
    impl From<WithParam> for ::prisma_client_rust::Selection {
        fn from(val: WithParam) -> Self {
            match val {
                WithParam::Book(args) => {
                    let mut selections =
                        <super::book::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                        );
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(book::NAME, None, [], selections)
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(i32),
        IncrementId(i32),
        DecrementId(i32),
        MultiplyId(i32),
        DivideId(i32),
        SetBookId(i32),
        IncrementBookId(i32),
        DecrementBookId(i32),
        MultiplyBookId(i32),
        DivideBookId(i32),
        SetTitle(String),
        SetText(String),
        SetFile(Option<String>),
        ConnectBook(super::book::UniqueWhereParam),
    }
    impl From<SetParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(param: SetParam) -> Self {
            match param {
                SetParam::SetId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetBookId(value) => (
                    book_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementBookId(value) => (
                    book_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementBookId(value) => (
                    book_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyBookId(value) => (
                    book_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideBookId(value) => (
                    book_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetTitle(value) => (
                    title::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetText(value) => (
                    text::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetFile(value) => (
                    file::NAME.to_string(),
                    value
                        .map(::prisma_client_rust::PrismaValue::String)
                        .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::ConnectBook(where_param) => (
                    book::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::book::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UncheckedSetParam {
        Id(i32),
        BookId(i32),
        Title(String),
        Text(String),
        File(Option<String>),
    }
    impl From<UncheckedSetParam> for SetParam {
        fn from(param: UncheckedSetParam) -> Self {
            match param {
                UncheckedSetParam::Id(value) => Self::SetId(value),
                UncheckedSetParam::BookId(value) => Self::SetBookId(value),
                UncheckedSetParam::Title(value) => Self::SetTitle(value),
                UncheckedSetParam::Text(value) => Self::SetText(value),
                UncheckedSetParam::File(value) => Self::SetFile(value),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        BookId(::prisma_client_rust::Direction),
        Title(::prisma_client_rust::Direction),
        Text(::prisma_client_rust::Direction),
        File(::prisma_client_rust::Direction),
    }
    impl From<OrderByParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(val: OrderByParam) -> Self {
            match val {
                OrderByParam::Id(direction) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                OrderByParam::BookId(direction) => (
                    book_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                OrderByParam::Title(direction) => (
                    title::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                OrderByParam::Text(direction) => (
                    text::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                OrderByParam::File(direction) => (
                    file::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        Id(_prisma::read_filters::IntFilter),
        BookId(_prisma::read_filters::IntFilter),
        Title(_prisma::read_filters::StringFilter),
        Text(_prisma::read_filters::StringFilter),
        File(_prisma::read_filters::StringNullableFilter),
        BookIs(Vec<super::book::WhereParam>),
        BookIsNot(Vec<super::book::WhereParam>),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Id(value) => (id::NAME, value.into()),
                Self::BookId(value) => (book_id::NAME, value.into()),
                Self::Title(value) => (title::NAME, value.into()),
                Self::Text(value) => (text::NAME, value.into()),
                Self::File(value) => (file::NAME, value.into()),
                Self::BookIs(where_params) => (
                    book::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::BookIsNot(where_params) => (
                    book::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value)
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        BookIdEquals(i32),
        IdEquals(i32),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::BookIdEquals(value) => {
                    Self::BookId(_prisma::read_filters::IntFilter::Equals(value))
                }
                UniqueWhereParam::IdEquals(value) => {
                    Self::Id(_prisma::read_filters::IntFilter::Equals(value))
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(id::NAME),
                ::prisma_client_rust::sel(book_id::NAME),
                ::prisma_client_rust::sel(title::NAME),
                ::prisma_client_rust::sel(text::NAME),
                ::prisma_client_rust::sel(file::NAME),
            ]
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            title: String,
            text: String,
            book: super::book::UniqueWhereParam,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.extend([title::set(title), text::set(text), book::connect(book)]);
            Create::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            book_id: i32,
            title: String,
            text: String,
            mut _params: Vec<UncheckedSetParam>,
        ) -> Create<'a> {
            _params.extend([book_id::set(book_id), title::set(title), text::set(text)]);
            Create::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn create_many(
            self,
            data: Vec<(i32, String, String, Vec<SetParam>)>,
        ) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(book_id, title, text, mut _params)| {
                    _params.extend([book_id::set(book_id), title::set(title), text::set(text)]);
                    _params
                })
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> Update<'a> {
            Update::new(
                self.client,
                _where.into(),
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (title, text, book, mut _params): (
                String,
                String,
                super::book::UniqueWhereParam,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.extend([title::set(title), text::set(text), book::connect(book)]);
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
        pub fn find_raw<T: ::prisma_client_rust::Data>(
            self,
        ) -> ::prisma_client_rust::FindRaw<'a, Types, T> {
            ::prisma_client_rust::FindRaw::new(self.client)
        }
        pub fn aggregate_raw<T: ::prisma_client_rust::Data>(
            self,
        ) -> ::prisma_client_rust::AggregateRaw<'a, Types, T> {
            ::prisma_client_rust::AggregateRaw::new(self.client)
        }
    }
}
pub mod book_author {
    
    use super::*;
    pub const NAME: &str = "BookAuthor";
    pub mod id {
        use super::super::*;
        
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam,
        };
        pub const NAME: &str = "id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Id, {
            fn in_vec(_: Vec<i32>) -> InVec;
            fn not_in_vec(_: Vec<i32>) -> NotInVec;
            fn lt(_: i32) -> Lt;
            fn lte(_: i32) -> Lte;
            fn gt(_: i32) -> Gt;
            fn gte(_: i32) -> Gte;
            fn not(_: i32) -> Not;
        });
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideId(value)
        }
        pub struct Include;
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::Id(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::Id(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod author_id {
        use super::super::*;
        
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "author_id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetAuthorId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::AuthorId(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::AuthorId(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::AuthorId(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntFilter,
            AuthorId,
            {
                fn in_vec(_: Vec<i32>) -> InVec;
                fn not_in_vec(_: Vec<i32>) -> NotInVec;
                fn lt(_: i32) -> Lt;
                fn lte(_: i32) -> Lte;
                fn gt(_: i32) -> Gt;
                fn gte(_: i32) -> Gte;
                fn not(_: i32) -> Not;
            }
        );
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementAuthorId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementAuthorId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyAuthorId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideAuthorId(value)
        }
        pub struct Include;
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::AuthorId(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::AuthorId(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod book_id {
        use super::super::*;
        
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "book_id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetBookId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::BookId(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::BookId(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::BookId(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, BookId, {
            fn in_vec(_: Vec<i32>) -> InVec;
            fn not_in_vec(_: Vec<i32>) -> NotInVec;
            fn lt(_: i32) -> Lt;
            fn lte(_: i32) -> Lte;
            fn gt(_: i32) -> Gt;
            fn gte(_: i32) -> Gte;
            fn not(_: i32) -> Not;
        });
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementBookId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementBookId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyBookId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideBookId(value)
        }
        pub struct Include;
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::BookId(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::BookId(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod author {
        use super::super::*;
        
        use super::{
            SetParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "author";
        pub struct Fetch(pub author::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<author::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Author(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(author::UniqueArgs::new())
        }
        pub struct Connect(author::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectAuthor(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: author::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn is(value: Vec<author::WhereParam>) -> WhereParam {
            WhereParam::AuthorIs(value)
        }
        pub fn is_not(value: Vec<author::WhereParam>) -> WhereParam {
            WhereParam::AuthorIsNot(value)
        }
        pub enum Include {
            Select(Vec<author::SelectParam>),
            Include(Vec<author::IncludeParam>),
            Fetch,
        }
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::Author(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections =
                            <author::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                            );
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <author::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("author", None, [], selections)
            }
            pub fn select(nested_selections: Vec<author::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<author::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<author::SelectParam>),
            Include(Vec<author::IncludeParam>),
            Fetch,
        }
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::Author(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <author::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("author", None, [], selections)
            }
            pub fn select(nested_selections: Vec<author::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<author::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub mod book {
        use super::super::*;
        
        use super::{
            SetParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "book";
        pub struct Fetch(pub book::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<book::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Book(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(book::UniqueArgs::new())
        }
        pub struct Connect(book::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectBook(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: book::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn is(value: Vec<book::WhereParam>) -> WhereParam {
            WhereParam::BookIs(value)
        }
        pub fn is_not(value: Vec<book::WhereParam>) -> WhereParam {
            WhereParam::BookIsNot(value)
        }
        pub enum Include {
            Select(Vec<book::SelectParam>),
            Include(Vec<book::IncludeParam>),
            Fetch,
        }
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::Book(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections =
                            <book::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <book::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("book", None, [], selections)
            }
            pub fn select(nested_selections: Vec<book::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<book::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<book::SelectParam>),
            Include(Vec<book::IncludeParam>),
            Fetch,
        }
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::Book(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <book::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("book", None, [], selections)
            }
            pub fn select(nested_selections: Vec<book::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<book::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub fn book_id_author_id<T: From<UniqueWhereParam>>(book_id: i32, author_id: i32) -> T {
        UniqueWhereParam::BookIdAuthorIdEquals(book_id, author_id).into()
    }
    pub fn create(
        author: super::author::UniqueWhereParam,
        book: super::book::UniqueWhereParam,
        _params: Vec<SetParam>,
    ) -> (
        super::author::UniqueWhereParam,
        super::book::UniqueWhereParam,
        Vec<SetParam>,
    ) {
        (author, book, _params)
    }
    pub fn create_unchecked(
        author_id: i32,
        book_id: i32,
        _params: Vec<SetParam>,
    ) -> (i32, i32, Vec<SetParam>) {
        (author_id, book_id, _params)
    }
    #[macro_export]
    macro_rules ! _select_book_author { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $crate :: prisma :: book_author :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = $crate :: prisma :: book_author :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: book_author :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: book_author :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: book_author :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: book_author :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , author_id , book_id , author , book } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : crate :: prisma :: book_author :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: book_author :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: book_author :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: book_author :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: book_author :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: book_author :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "author_id" , "book_id" , "author" , "book"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: book_author :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i32 } ; (@ field_type ; author_id) => { i32 } ; (@ field_type ; book_id) => { i32 } ; (@ field_type ; author : $ selection_mode : ident { $ ($ selections : tt) + }) => { author :: Data } ; (@ field_type ; author) => { crate :: prisma :: author :: Data } ; (@ field_type ; book : $ selection_mode : ident { $ ($ selections : tt) + }) => { book :: Data } ; (@ field_type ; book) => { crate :: prisma :: book :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "BookAuthor" , available relations are "id, author_id, book_id, author, book")) } ; (@ field_module ; author : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: author :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; book : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: book :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: book_author :: SelectParam > :: into (crate :: prisma :: book_author :: id :: Select) } ; (@ selection_field_to_selection_param ; author_id) => { Into :: < crate :: prisma :: book_author :: SelectParam > :: into (crate :: prisma :: book_author :: author_id :: Select) } ; (@ selection_field_to_selection_param ; book_id) => { Into :: < crate :: prisma :: book_author :: SelectParam > :: into (crate :: prisma :: book_author :: book_id :: Select) } ; (@ selection_field_to_selection_param ; author $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: book_author :: SelectParam > :: into (crate :: prisma :: book_author :: author :: Select :: $ selection_mode (crate :: prisma :: author :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; author $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: book_author :: SelectParam > :: into (crate :: prisma :: book_author :: author :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; book $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: book_author :: SelectParam > :: into (crate :: prisma :: book_author :: book :: Select :: $ selection_mode (crate :: prisma :: book :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; book $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: book_author :: SelectParam > :: into (crate :: prisma :: book_author :: book :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: book_author :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; author_id) => { "author_id" } ; (@ field_serde_name ; book_id) => { "book_id" } ; (@ field_serde_name ; author) => { "author" } ; (@ field_serde_name ; book) => { "book" } ; }
    pub use _select_book_author as select;
    pub enum SelectParam {
        Id(id::Select),
        AuthorId(author_id::Select),
        BookId(book_id::Select),
        Author(author::Select),
        Book(book::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::AuthorId(data) => data.to_selection(),
                Self::BookId(data) => data.to_selection(),
                Self::Author(data) => data.to_selection(),
                Self::Book(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_book_author { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $crate :: prisma :: book_author :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = $crate :: prisma :: book_author :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: book_author :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: book_author :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: book_author :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: book_author :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: book_author :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: book_author :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { author , book } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : i32 , pub author_id : i32 , pub book_id : i32 , $ (pub $ field : crate :: prisma :: book_author :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (author_id) , stringify ! (book_id)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: book_author :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: book_author :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: book_author :: author_id :: NAME , & self . author_id) ? ; state . serialize_field (crate :: prisma :: book_author :: book_id :: NAME , & self . book_id) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , author_id , book_id } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: book_author :: $ field :: NAME) , + , crate :: prisma :: book_author :: id :: NAME , crate :: prisma :: book_author :: author_id :: NAME , crate :: prisma :: book_author :: book_id :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: book_author :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: book_author :: id :: NAME => Ok (Field :: id) , crate :: prisma :: book_author :: author_id :: NAME => Ok (Field :: author_id) , crate :: prisma :: book_author :: book_id :: NAME => Ok (Field :: book_id) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut author_id = None ; let mut book_id = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: book_author :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: author_id => { if author_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: book_author :: author_id :: NAME)) ; } author_id = Some (map . next_value () ?) ; } Field :: book_id => { if book_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: book_author :: book_id :: NAME)) ; } book_id = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: book_author :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: book_author :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: book_author :: id :: NAME)) ? ; let author_id = author_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: book_author :: author_id :: NAME)) ? ; let book_id = book_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: book_author :: book_id :: NAME)) ? ; Ok (Data { id , author_id , book_id , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "author_id" , "book_id" , "author" , "book"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: book_author :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; author : $ selection_mode : ident { $ ($ selections : tt) + }) => { author :: Data } ; (@ field_type ; author) => { crate :: prisma :: author :: Data } ; (@ field_type ; book : $ selection_mode : ident { $ ($ selections : tt) + }) => { book :: Data } ; (@ field_type ; book) => { crate :: prisma :: book :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "BookAuthor" , available relations are "author, book")) } ; (@ field_module ; author : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: author :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; book : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: book :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; author $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: book_author :: IncludeParam > :: into (crate :: prisma :: book_author :: author :: Include :: $ selection_mode (crate :: prisma :: author :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; author $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: book_author :: IncludeParam > :: into (crate :: prisma :: book_author :: author :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; book $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: book_author :: IncludeParam > :: into (crate :: prisma :: book_author :: book :: Include :: $ selection_mode (crate :: prisma :: book :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; book $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: book_author :: IncludeParam > :: into (crate :: prisma :: book_author :: book :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: book_author :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; author_id) => { "author_id" } ; (@ field_serde_name ; book_id) => { "book_id" } ; (@ field_serde_name ; author) => { "author" } ; (@ field_serde_name ; book) => { "book" } ; }
    pub use _include_book_author as include;
    pub enum IncludeParam {
        Id(id::Include),
        AuthorId(author_id::Include),
        BookId(book_id::Include),
        Author(author::Include),
        Book(book::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::AuthorId(data) => data.to_selection(),
                Self::BookId(data) => data.to_selection(),
                Self::Author(data) => data.to_selection(),
                Self::Book(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _partial_unchecked_book_author { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { $crate :: prisma :: book_author struct $ struct_name { # [serde (rename = "id")] pub id : i32 , # [serde (rename = "author_id")] pub author_id : i32 , # [serde (rename = "book_id")] pub book_id : i32 } [$ ($ scalar_field) , +] } } ; }
    pub use _partial_unchecked_book_author as partial_unchecked;
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: i32,
        #[serde(rename = "author_id")]
        pub author_id: i32,
        #[serde(rename = "book_id")]
        pub book_id: i32,
        #[serde(rename = "author")]
        pub author: Option<Box<super::author::Data>>,
        #[serde(rename = "book")]
        pub book: Option<Box<super::book::Data>>,
    }
    impl Data {
        pub fn author(
            &self,
        ) -> Result<&super::author::Data, ::prisma_client_rust::RelationNotFetchedError> {
            self.author
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(author),
                ))
                .map(|v| v.as_ref())
        }
        pub fn book(
            &self,
        ) -> Result<&super::book::Data, ::prisma_client_rust::RelationNotFetchedError> {
            self.book
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(book),
                ))
                .map(|v| v.as_ref())
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        Author(super::author::UniqueArgs),
        Book(super::book::UniqueArgs),
    }
    impl From<WithParam> for ::prisma_client_rust::Selection {
        fn from(val: WithParam) -> Self {
            match val {
                WithParam::Author(args) => {
                    let mut selections = < super :: author :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(author::NAME, None, [], selections)
                }
                WithParam::Book(args) => {
                    let mut selections =
                        <super::book::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                        );
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(book::NAME, None, [], selections)
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(i32),
        IncrementId(i32),
        DecrementId(i32),
        MultiplyId(i32),
        DivideId(i32),
        SetAuthorId(i32),
        IncrementAuthorId(i32),
        DecrementAuthorId(i32),
        MultiplyAuthorId(i32),
        DivideAuthorId(i32),
        SetBookId(i32),
        IncrementBookId(i32),
        DecrementBookId(i32),
        MultiplyBookId(i32),
        DivideBookId(i32),
        ConnectAuthor(super::author::UniqueWhereParam),
        ConnectBook(super::book::UniqueWhereParam),
    }
    impl From<SetParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(param: SetParam) -> Self {
            match param {
                SetParam::SetId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetAuthorId(value) => (
                    author_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementAuthorId(value) => (
                    author_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementAuthorId(value) => (
                    author_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyAuthorId(value) => (
                    author_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideAuthorId(value) => (
                    author_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetBookId(value) => (
                    book_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementBookId(value) => (
                    book_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementBookId(value) => (
                    book_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyBookId(value) => (
                    book_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideBookId(value) => (
                    book_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::ConnectAuthor(where_param) => (
                    author::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::author::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectBook(where_param) => (
                    book::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::book::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UncheckedSetParam {
        Id(i32),
        AuthorId(i32),
        BookId(i32),
    }
    impl From<UncheckedSetParam> for SetParam {
        fn from(param: UncheckedSetParam) -> Self {
            match param {
                UncheckedSetParam::Id(value) => Self::SetId(value),
                UncheckedSetParam::AuthorId(value) => Self::SetAuthorId(value),
                UncheckedSetParam::BookId(value) => Self::SetBookId(value),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        AuthorId(::prisma_client_rust::Direction),
        BookId(::prisma_client_rust::Direction),
    }
    impl From<OrderByParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(val: OrderByParam) -> Self {
            match val {
                OrderByParam::Id(direction) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                OrderByParam::AuthorId(direction) => (
                    author_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                OrderByParam::BookId(direction) => (
                    book_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        BookIdAuthorIdEquals(i32, i32),
        Id(_prisma::read_filters::IntFilter),
        AuthorId(_prisma::read_filters::IntFilter),
        BookId(_prisma::read_filters::IntFilter),
        AuthorIs(Vec<super::author::WhereParam>),
        AuthorIsNot(Vec<super::author::WhereParam>),
        BookIs(Vec<super::book::WhereParam>),
        BookIsNot(Vec<super::book::WhereParam>),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::BookIdAuthorIdEquals(book_id, author_id) => (
                    "book_id_author_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![
                        (
                            book_id::NAME.to_string(),
                            ::prisma_client_rust::PrismaValue::Int(book_id as i64),
                        ),
                        (
                            author_id::NAME.to_string(),
                            ::prisma_client_rust::PrismaValue::Int(author_id as i64),
                        ),
                    ]),
                ),
                Self::Id(value) => (id::NAME, value.into()),
                Self::AuthorId(value) => (author_id::NAME, value.into()),
                Self::BookId(value) => (book_id::NAME, value.into()),
                Self::AuthorIs(where_params) => (
                    author::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::AuthorIsNot(where_params) => (
                    author::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::BookIs(where_params) => (
                    book::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::BookIsNot(where_params) => (
                    book::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value)
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        BookIdAuthorIdEquals(i32, i32),
        IdEquals(i32),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::BookIdAuthorIdEquals(book_id, author_id) => {
                    Self::BookIdAuthorIdEquals(book_id, author_id)
                }
                UniqueWhereParam::IdEquals(value) => {
                    Self::Id(_prisma::read_filters::IntFilter::Equals(value))
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(id::NAME),
                ::prisma_client_rust::sel(author_id::NAME),
                ::prisma_client_rust::sel(book_id::NAME),
            ]
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            author: super::author::UniqueWhereParam,
            book: super::book::UniqueWhereParam,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.extend([author::connect(author), book::connect(book)]);
            Create::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            author_id: i32,
            book_id: i32,
            mut _params: Vec<UncheckedSetParam>,
        ) -> Create<'a> {
            _params.extend([author_id::set(author_id), book_id::set(book_id)]);
            Create::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn create_many(self, data: Vec<(i32, i32, Vec<SetParam>)>) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(author_id, book_id, mut _params)| {
                    _params.extend([author_id::set(author_id), book_id::set(book_id)]);
                    _params
                })
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> Update<'a> {
            Update::new(
                self.client,
                _where.into(),
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (author, book, mut _params): (
                super::author::UniqueWhereParam,
                super::book::UniqueWhereParam,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.extend([author::connect(author), book::connect(book)]);
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
        pub fn find_raw<T: ::prisma_client_rust::Data>(
            self,
        ) -> ::prisma_client_rust::FindRaw<'a, Types, T> {
            ::prisma_client_rust::FindRaw::new(self.client)
        }
        pub fn aggregate_raw<T: ::prisma_client_rust::Data>(
            self,
        ) -> ::prisma_client_rust::AggregateRaw<'a, Types, T> {
            ::prisma_client_rust::AggregateRaw::new(self.client)
        }
    }
}
pub mod book_genre {
    
    use super::*;
    pub const NAME: &str = "BookGenre";
    pub mod id {
        use super::super::*;
        
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam,
        };
        pub const NAME: &str = "id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Id, {
            fn in_vec(_: Vec<i32>) -> InVec;
            fn not_in_vec(_: Vec<i32>) -> NotInVec;
            fn lt(_: i32) -> Lt;
            fn lte(_: i32) -> Lte;
            fn gt(_: i32) -> Gt;
            fn gte(_: i32) -> Gte;
            fn not(_: i32) -> Not;
        });
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideId(value)
        }
        pub struct Include;
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::Id(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::Id(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod genre_id {
        use super::super::*;
        
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "genre_id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetGenreId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::GenreId(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::GenreId(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::GenreId(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, GenreId, {
            fn in_vec(_: Vec<i32>) -> InVec;
            fn not_in_vec(_: Vec<i32>) -> NotInVec;
            fn lt(_: i32) -> Lt;
            fn lte(_: i32) -> Lte;
            fn gt(_: i32) -> Gt;
            fn gte(_: i32) -> Gte;
            fn not(_: i32) -> Not;
        });
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementGenreId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementGenreId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyGenreId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideGenreId(value)
        }
        pub struct Include;
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::GenreId(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::GenreId(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod book_id {
        use super::super::*;
        
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "book_id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetBookId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::BookId(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::BookId(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::BookId(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, BookId, {
            fn in_vec(_: Vec<i32>) -> InVec;
            fn not_in_vec(_: Vec<i32>) -> NotInVec;
            fn lt(_: i32) -> Lt;
            fn lte(_: i32) -> Lte;
            fn gt(_: i32) -> Gt;
            fn gte(_: i32) -> Gte;
            fn not(_: i32) -> Not;
        });
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementBookId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementBookId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyBookId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideBookId(value)
        }
        pub struct Include;
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::BookId(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::BookId(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod book {
        use super::super::*;
        
        use super::{
            SetParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "book";
        pub struct Fetch(pub book::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<book::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Book(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(book::UniqueArgs::new())
        }
        pub struct Connect(book::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectBook(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: book::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn is(value: Vec<book::WhereParam>) -> WhereParam {
            WhereParam::BookIs(value)
        }
        pub fn is_not(value: Vec<book::WhereParam>) -> WhereParam {
            WhereParam::BookIsNot(value)
        }
        pub enum Include {
            Select(Vec<book::SelectParam>),
            Include(Vec<book::IncludeParam>),
            Fetch,
        }
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::Book(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections =
                            <book::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <book::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("book", None, [], selections)
            }
            pub fn select(nested_selections: Vec<book::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<book::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<book::SelectParam>),
            Include(Vec<book::IncludeParam>),
            Fetch,
        }
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::Book(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <book::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("book", None, [], selections)
            }
            pub fn select(nested_selections: Vec<book::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<book::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub mod genre {
        use super::super::*;
        
        use super::{
            SetParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "genre";
        pub struct Fetch(pub genre::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<genre::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Genre(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(genre::UniqueArgs::new())
        }
        pub struct Connect(genre::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectGenre(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: genre::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn is(value: Vec<genre::WhereParam>) -> WhereParam {
            WhereParam::GenreIs(value)
        }
        pub fn is_not(value: Vec<genre::WhereParam>) -> WhereParam {
            WhereParam::GenreIsNot(value)
        }
        pub enum Include {
            Select(Vec<genre::SelectParam>),
            Include(Vec<genre::IncludeParam>),
            Fetch,
        }
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::Genre(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections =
                            <genre::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <genre::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("genre", None, [], selections)
            }
            pub fn select(nested_selections: Vec<genre::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<genre::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<genre::SelectParam>),
            Include(Vec<genre::IncludeParam>),
            Fetch,
        }
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::Genre(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <genre::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("genre", None, [], selections)
            }
            pub fn select(nested_selections: Vec<genre::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<genre::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub fn book_id_genre_id<T: From<UniqueWhereParam>>(book_id: i32, genre_id: i32) -> T {
        UniqueWhereParam::BookIdGenreIdEquals(book_id, genre_id).into()
    }
    pub fn create(
        book: super::book::UniqueWhereParam,
        genre: super::genre::UniqueWhereParam,
        _params: Vec<SetParam>,
    ) -> (
        super::book::UniqueWhereParam,
        super::genre::UniqueWhereParam,
        Vec<SetParam>,
    ) {
        (book, genre, _params)
    }
    pub fn create_unchecked(
        genre_id: i32,
        book_id: i32,
        _params: Vec<SetParam>,
    ) -> (i32, i32, Vec<SetParam>) {
        (genre_id, book_id, _params)
    }
    #[macro_export]
    macro_rules ! _select_book_genre { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $crate :: prisma :: book_genre :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = $crate :: prisma :: book_genre :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: book_genre :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: book_genre :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: book_genre :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: book_genre :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , genre_id , book_id , book , genre } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : crate :: prisma :: book_genre :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: book_genre :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: book_genre :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: book_genre :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: book_genre :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: book_genre :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "genre_id" , "book_id" , "book" , "genre"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: book_genre :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i32 } ; (@ field_type ; genre_id) => { i32 } ; (@ field_type ; book_id) => { i32 } ; (@ field_type ; book : $ selection_mode : ident { $ ($ selections : tt) + }) => { book :: Data } ; (@ field_type ; book) => { crate :: prisma :: book :: Data } ; (@ field_type ; genre : $ selection_mode : ident { $ ($ selections : tt) + }) => { genre :: Data } ; (@ field_type ; genre) => { crate :: prisma :: genre :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "BookGenre" , available relations are "id, genre_id, book_id, book, genre")) } ; (@ field_module ; book : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: book :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; genre : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: genre :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: book_genre :: SelectParam > :: into (crate :: prisma :: book_genre :: id :: Select) } ; (@ selection_field_to_selection_param ; genre_id) => { Into :: < crate :: prisma :: book_genre :: SelectParam > :: into (crate :: prisma :: book_genre :: genre_id :: Select) } ; (@ selection_field_to_selection_param ; book_id) => { Into :: < crate :: prisma :: book_genre :: SelectParam > :: into (crate :: prisma :: book_genre :: book_id :: Select) } ; (@ selection_field_to_selection_param ; book $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: book_genre :: SelectParam > :: into (crate :: prisma :: book_genre :: book :: Select :: $ selection_mode (crate :: prisma :: book :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; book $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: book_genre :: SelectParam > :: into (crate :: prisma :: book_genre :: book :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; genre $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: book_genre :: SelectParam > :: into (crate :: prisma :: book_genre :: genre :: Select :: $ selection_mode (crate :: prisma :: genre :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; genre $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: book_genre :: SelectParam > :: into (crate :: prisma :: book_genre :: genre :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: book_genre :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; genre_id) => { "genre_id" } ; (@ field_serde_name ; book_id) => { "book_id" } ; (@ field_serde_name ; book) => { "book" } ; (@ field_serde_name ; genre) => { "genre" } ; }
    pub use _select_book_genre as select;
    pub enum SelectParam {
        Id(id::Select),
        GenreId(genre_id::Select),
        BookId(book_id::Select),
        Book(book::Select),
        Genre(genre::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::GenreId(data) => data.to_selection(),
                Self::BookId(data) => data.to_selection(),
                Self::Book(data) => data.to_selection(),
                Self::Genre(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_book_genre { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $crate :: prisma :: book_genre :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = $crate :: prisma :: book_genre :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: book_genre :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: book_genre :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: book_genre :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: book_genre :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: book_genre :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: book_genre :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { book , genre } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : i32 , pub genre_id : i32 , pub book_id : i32 , $ (pub $ field : crate :: prisma :: book_genre :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (genre_id) , stringify ! (book_id)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: book_genre :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: book_genre :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: book_genre :: genre_id :: NAME , & self . genre_id) ? ; state . serialize_field (crate :: prisma :: book_genre :: book_id :: NAME , & self . book_id) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , genre_id , book_id } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: book_genre :: $ field :: NAME) , + , crate :: prisma :: book_genre :: id :: NAME , crate :: prisma :: book_genre :: genre_id :: NAME , crate :: prisma :: book_genre :: book_id :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: book_genre :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: book_genre :: id :: NAME => Ok (Field :: id) , crate :: prisma :: book_genre :: genre_id :: NAME => Ok (Field :: genre_id) , crate :: prisma :: book_genre :: book_id :: NAME => Ok (Field :: book_id) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut genre_id = None ; let mut book_id = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: book_genre :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: genre_id => { if genre_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: book_genre :: genre_id :: NAME)) ; } genre_id = Some (map . next_value () ?) ; } Field :: book_id => { if book_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: book_genre :: book_id :: NAME)) ; } book_id = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: book_genre :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: book_genre :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: book_genre :: id :: NAME)) ? ; let genre_id = genre_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: book_genre :: genre_id :: NAME)) ? ; let book_id = book_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: book_genre :: book_id :: NAME)) ? ; Ok (Data { id , genre_id , book_id , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "genre_id" , "book_id" , "book" , "genre"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: book_genre :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; book : $ selection_mode : ident { $ ($ selections : tt) + }) => { book :: Data } ; (@ field_type ; book) => { crate :: prisma :: book :: Data } ; (@ field_type ; genre : $ selection_mode : ident { $ ($ selections : tt) + }) => { genre :: Data } ; (@ field_type ; genre) => { crate :: prisma :: genre :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "BookGenre" , available relations are "book, genre")) } ; (@ field_module ; book : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: book :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; genre : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: genre :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; book $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: book_genre :: IncludeParam > :: into (crate :: prisma :: book_genre :: book :: Include :: $ selection_mode (crate :: prisma :: book :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; book $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: book_genre :: IncludeParam > :: into (crate :: prisma :: book_genre :: book :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; genre $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: book_genre :: IncludeParam > :: into (crate :: prisma :: book_genre :: genre :: Include :: $ selection_mode (crate :: prisma :: genre :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; genre $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: book_genre :: IncludeParam > :: into (crate :: prisma :: book_genre :: genre :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: book_genre :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; genre_id) => { "genre_id" } ; (@ field_serde_name ; book_id) => { "book_id" } ; (@ field_serde_name ; book) => { "book" } ; (@ field_serde_name ; genre) => { "genre" } ; }
    pub use _include_book_genre as include;
    pub enum IncludeParam {
        Id(id::Include),
        GenreId(genre_id::Include),
        BookId(book_id::Include),
        Book(book::Include),
        Genre(genre::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::GenreId(data) => data.to_selection(),
                Self::BookId(data) => data.to_selection(),
                Self::Book(data) => data.to_selection(),
                Self::Genre(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _partial_unchecked_book_genre { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { $crate :: prisma :: book_genre struct $ struct_name { # [serde (rename = "id")] pub id : i32 , # [serde (rename = "genre_id")] pub genre_id : i32 , # [serde (rename = "book_id")] pub book_id : i32 } [$ ($ scalar_field) , +] } } ; }
    pub use _partial_unchecked_book_genre as partial_unchecked;
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: i32,
        #[serde(rename = "genre_id")]
        pub genre_id: i32,
        #[serde(rename = "book_id")]
        pub book_id: i32,
        #[serde(rename = "book")]
        pub book: Option<Box<super::book::Data>>,
        #[serde(rename = "genre")]
        pub genre: Option<Box<super::genre::Data>>,
    }
    impl Data {
        pub fn book(
            &self,
        ) -> Result<&super::book::Data, ::prisma_client_rust::RelationNotFetchedError> {
            self.book
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(book),
                ))
                .map(|v| v.as_ref())
        }
        pub fn genre(
            &self,
        ) -> Result<&super::genre::Data, ::prisma_client_rust::RelationNotFetchedError> {
            self.genre
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(genre),
                ))
                .map(|v| v.as_ref())
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        Book(super::book::UniqueArgs),
        Genre(super::genre::UniqueArgs),
    }
    impl From<WithParam> for ::prisma_client_rust::Selection {
        fn from(val: WithParam) -> Self {
            match val {
                WithParam::Book(args) => {
                    let mut selections =
                        <super::book::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                        );
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(book::NAME, None, [], selections)
                }
                WithParam::Genre(args) => {
                    let mut selections = < super :: genre :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(genre::NAME, None, [], selections)
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(i32),
        IncrementId(i32),
        DecrementId(i32),
        MultiplyId(i32),
        DivideId(i32),
        SetGenreId(i32),
        IncrementGenreId(i32),
        DecrementGenreId(i32),
        MultiplyGenreId(i32),
        DivideGenreId(i32),
        SetBookId(i32),
        IncrementBookId(i32),
        DecrementBookId(i32),
        MultiplyBookId(i32),
        DivideBookId(i32),
        ConnectBook(super::book::UniqueWhereParam),
        ConnectGenre(super::genre::UniqueWhereParam),
    }
    impl From<SetParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(param: SetParam) -> Self {
            match param {
                SetParam::SetId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetGenreId(value) => (
                    genre_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementGenreId(value) => (
                    genre_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementGenreId(value) => (
                    genre_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyGenreId(value) => (
                    genre_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideGenreId(value) => (
                    genre_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetBookId(value) => (
                    book_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementBookId(value) => (
                    book_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementBookId(value) => (
                    book_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyBookId(value) => (
                    book_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideBookId(value) => (
                    book_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::ConnectBook(where_param) => (
                    book::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::book::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectGenre(where_param) => (
                    genre::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::genre::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UncheckedSetParam {
        Id(i32),
        GenreId(i32),
        BookId(i32),
    }
    impl From<UncheckedSetParam> for SetParam {
        fn from(param: UncheckedSetParam) -> Self {
            match param {
                UncheckedSetParam::Id(value) => Self::SetId(value),
                UncheckedSetParam::GenreId(value) => Self::SetGenreId(value),
                UncheckedSetParam::BookId(value) => Self::SetBookId(value),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        GenreId(::prisma_client_rust::Direction),
        BookId(::prisma_client_rust::Direction),
    }
    impl From<OrderByParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(val: OrderByParam) -> Self {
            match val {
                OrderByParam::Id(direction) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                OrderByParam::GenreId(direction) => (
                    genre_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                OrderByParam::BookId(direction) => (
                    book_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        BookIdGenreIdEquals(i32, i32),
        Id(_prisma::read_filters::IntFilter),
        GenreId(_prisma::read_filters::IntFilter),
        BookId(_prisma::read_filters::IntFilter),
        BookIs(Vec<super::book::WhereParam>),
        BookIsNot(Vec<super::book::WhereParam>),
        GenreIs(Vec<super::genre::WhereParam>),
        GenreIsNot(Vec<super::genre::WhereParam>),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::BookIdGenreIdEquals(book_id, genre_id) => (
                    "book_id_genre_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![
                        (
                            book_id::NAME.to_string(),
                            ::prisma_client_rust::PrismaValue::Int(book_id as i64),
                        ),
                        (
                            genre_id::NAME.to_string(),
                            ::prisma_client_rust::PrismaValue::Int(genre_id as i64),
                        ),
                    ]),
                ),
                Self::Id(value) => (id::NAME, value.into()),
                Self::GenreId(value) => (genre_id::NAME, value.into()),
                Self::BookId(value) => (book_id::NAME, value.into()),
                Self::BookIs(where_params) => (
                    book::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::BookIsNot(where_params) => (
                    book::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::GenreIs(where_params) => (
                    genre::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::GenreIsNot(where_params) => (
                    genre::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value)
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        BookIdGenreIdEquals(i32, i32),
        IdEquals(i32),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::BookIdGenreIdEquals(book_id, genre_id) => {
                    Self::BookIdGenreIdEquals(book_id, genre_id)
                }
                UniqueWhereParam::IdEquals(value) => {
                    Self::Id(_prisma::read_filters::IntFilter::Equals(value))
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(id::NAME),
                ::prisma_client_rust::sel(genre_id::NAME),
                ::prisma_client_rust::sel(book_id::NAME),
            ]
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            book: super::book::UniqueWhereParam,
            genre: super::genre::UniqueWhereParam,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.extend([book::connect(book), genre::connect(genre)]);
            Create::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            genre_id: i32,
            book_id: i32,
            mut _params: Vec<UncheckedSetParam>,
        ) -> Create<'a> {
            _params.extend([genre_id::set(genre_id), book_id::set(book_id)]);
            Create::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn create_many(self, data: Vec<(i32, i32, Vec<SetParam>)>) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(genre_id, book_id, mut _params)| {
                    _params.extend([genre_id::set(genre_id), book_id::set(book_id)]);
                    _params
                })
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> Update<'a> {
            Update::new(
                self.client,
                _where.into(),
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (book, genre, mut _params): (
                super::book::UniqueWhereParam,
                super::genre::UniqueWhereParam,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.extend([book::connect(book), genre::connect(genre)]);
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
        pub fn find_raw<T: ::prisma_client_rust::Data>(
            self,
        ) -> ::prisma_client_rust::FindRaw<'a, Types, T> {
            ::prisma_client_rust::FindRaw::new(self.client)
        }
        pub fn aggregate_raw<T: ::prisma_client_rust::Data>(
            self,
        ) -> ::prisma_client_rust::AggregateRaw<'a, Types, T> {
            ::prisma_client_rust::AggregateRaw::new(self.client)
        }
    }
}
pub mod book_sequence {
    
    use super::*;
    pub const NAME: &str = "BookSequence";
    pub mod id {
        use super::super::*;
        
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam,
        };
        pub const NAME: &str = "id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Id, {
            fn in_vec(_: Vec<i32>) -> InVec;
            fn not_in_vec(_: Vec<i32>) -> NotInVec;
            fn lt(_: i32) -> Lt;
            fn lte(_: i32) -> Lte;
            fn gt(_: i32) -> Gt;
            fn gte(_: i32) -> Gte;
            fn not(_: i32) -> Not;
        });
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideId(value)
        }
        pub struct Include;
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::Id(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::Id(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod position {
        use super::super::*;
        
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "position";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetPosition(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Position(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Position(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::Position(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntFilter,
            Position,
            {
                fn in_vec(_: Vec<i32>) -> InVec;
                fn not_in_vec(_: Vec<i32>) -> NotInVec;
                fn lt(_: i32) -> Lt;
                fn lte(_: i32) -> Lte;
                fn gt(_: i32) -> Gt;
                fn gte(_: i32) -> Gte;
                fn not(_: i32) -> Not;
            }
        );
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementPosition(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementPosition(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyPosition(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DividePosition(value)
        }
        pub struct Include;
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::Position(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::Position(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod sequence_id {
        use super::super::*;
        
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "sequence_id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetSequenceId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::SequenceId(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::SequenceId(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::SequenceId(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntFilter,
            SequenceId,
            {
                fn in_vec(_: Vec<i32>) -> InVec;
                fn not_in_vec(_: Vec<i32>) -> NotInVec;
                fn lt(_: i32) -> Lt;
                fn lte(_: i32) -> Lte;
                fn gt(_: i32) -> Gt;
                fn gte(_: i32) -> Gte;
                fn not(_: i32) -> Not;
            }
        );
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementSequenceId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementSequenceId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplySequenceId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideSequenceId(value)
        }
        pub struct Include;
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::SequenceId(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::SequenceId(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod book_id {
        use super::super::*;
        
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "book_id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetBookId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::BookId(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::BookId(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::BookId(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, BookId, {
            fn in_vec(_: Vec<i32>) -> InVec;
            fn not_in_vec(_: Vec<i32>) -> NotInVec;
            fn lt(_: i32) -> Lt;
            fn lte(_: i32) -> Lte;
            fn gt(_: i32) -> Gt;
            fn gte(_: i32) -> Gte;
            fn not(_: i32) -> Not;
        });
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementBookId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementBookId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyBookId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideBookId(value)
        }
        pub struct Include;
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::BookId(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::BookId(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod book {
        use super::super::*;
        
        use super::{
            SetParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "book";
        pub struct Fetch(pub book::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<book::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Book(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(book::UniqueArgs::new())
        }
        pub struct Connect(book::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectBook(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: book::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn is(value: Vec<book::WhereParam>) -> WhereParam {
            WhereParam::BookIs(value)
        }
        pub fn is_not(value: Vec<book::WhereParam>) -> WhereParam {
            WhereParam::BookIsNot(value)
        }
        pub enum Include {
            Select(Vec<book::SelectParam>),
            Include(Vec<book::IncludeParam>),
            Fetch,
        }
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::Book(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections =
                            <book::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <book::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("book", None, [], selections)
            }
            pub fn select(nested_selections: Vec<book::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<book::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<book::SelectParam>),
            Include(Vec<book::IncludeParam>),
            Fetch,
        }
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::Book(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <book::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("book", None, [], selections)
            }
            pub fn select(nested_selections: Vec<book::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<book::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub mod sequence {
        use super::super::*;
        
        use super::{
            SetParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "sequence";
        pub struct Fetch(pub sequence::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<sequence::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Sequence(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(sequence::UniqueArgs::new())
        }
        pub struct Connect(sequence::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectSequence(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: sequence::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn is(value: Vec<sequence::WhereParam>) -> WhereParam {
            WhereParam::SequenceIs(value)
        }
        pub fn is_not(value: Vec<sequence::WhereParam>) -> WhereParam {
            WhereParam::SequenceIsNot(value)
        }
        pub enum Include {
            Select(Vec<sequence::SelectParam>),
            Include(Vec<sequence::IncludeParam>),
            Fetch,
        }
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::Sequence(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = < sequence :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <sequence::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("sequence", None, [], selections)
            }
            pub fn select(nested_selections: Vec<sequence::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<sequence::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<sequence::SelectParam>),
            Include(Vec<sequence::IncludeParam>),
            Fetch,
        }
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::Sequence(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <sequence::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("sequence", None, [], selections)
            }
            pub fn select(nested_selections: Vec<sequence::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<sequence::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub fn book_id_sequence_id<T: From<UniqueWhereParam>>(book_id: i32, sequence_id: i32) -> T {
        UniqueWhereParam::BookIdSequenceIdEquals(book_id, sequence_id).into()
    }
    pub fn create(
        position: i32,
        book: super::book::UniqueWhereParam,
        sequence: super::sequence::UniqueWhereParam,
        _params: Vec<SetParam>,
    ) -> (
        i32,
        super::book::UniqueWhereParam,
        super::sequence::UniqueWhereParam,
        Vec<SetParam>,
    ) {
        (position, book, sequence, _params)
    }
    pub fn create_unchecked(
        position: i32,
        sequence_id: i32,
        book_id: i32,
        _params: Vec<SetParam>,
    ) -> (i32, i32, i32, Vec<SetParam>) {
        (position, sequence_id, book_id, _params)
    }
    #[macro_export]
    macro_rules ! _select_book_sequence { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $crate :: prisma :: book_sequence :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = $crate :: prisma :: book_sequence :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: book_sequence :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: book_sequence :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: book_sequence :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: book_sequence :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , position , sequence_id , book_id , book , sequence } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : crate :: prisma :: book_sequence :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: book_sequence :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: book_sequence :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: book_sequence :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: book_sequence :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: book_sequence :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "position" , "sequence_id" , "book_id" , "book" , "sequence"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: book_sequence :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i32 } ; (@ field_type ; position) => { i32 } ; (@ field_type ; sequence_id) => { i32 } ; (@ field_type ; book_id) => { i32 } ; (@ field_type ; book : $ selection_mode : ident { $ ($ selections : tt) + }) => { book :: Data } ; (@ field_type ; book) => { crate :: prisma :: book :: Data } ; (@ field_type ; sequence : $ selection_mode : ident { $ ($ selections : tt) + }) => { sequence :: Data } ; (@ field_type ; sequence) => { crate :: prisma :: sequence :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "BookSequence" , available relations are "id, position, sequence_id, book_id, book, sequence")) } ; (@ field_module ; book : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: book :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; sequence : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: sequence :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: book_sequence :: SelectParam > :: into (crate :: prisma :: book_sequence :: id :: Select) } ; (@ selection_field_to_selection_param ; position) => { Into :: < crate :: prisma :: book_sequence :: SelectParam > :: into (crate :: prisma :: book_sequence :: position :: Select) } ; (@ selection_field_to_selection_param ; sequence_id) => { Into :: < crate :: prisma :: book_sequence :: SelectParam > :: into (crate :: prisma :: book_sequence :: sequence_id :: Select) } ; (@ selection_field_to_selection_param ; book_id) => { Into :: < crate :: prisma :: book_sequence :: SelectParam > :: into (crate :: prisma :: book_sequence :: book_id :: Select) } ; (@ selection_field_to_selection_param ; book $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: book_sequence :: SelectParam > :: into (crate :: prisma :: book_sequence :: book :: Select :: $ selection_mode (crate :: prisma :: book :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; book $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: book_sequence :: SelectParam > :: into (crate :: prisma :: book_sequence :: book :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; sequence $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: book_sequence :: SelectParam > :: into (crate :: prisma :: book_sequence :: sequence :: Select :: $ selection_mode (crate :: prisma :: sequence :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; sequence $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: book_sequence :: SelectParam > :: into (crate :: prisma :: book_sequence :: sequence :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: book_sequence :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; position) => { "position" } ; (@ field_serde_name ; sequence_id) => { "sequence_id" } ; (@ field_serde_name ; book_id) => { "book_id" } ; (@ field_serde_name ; book) => { "book" } ; (@ field_serde_name ; sequence) => { "sequence" } ; }
    pub use _select_book_sequence as select;
    pub enum SelectParam {
        Id(id::Select),
        Position(position::Select),
        SequenceId(sequence_id::Select),
        BookId(book_id::Select),
        Book(book::Select),
        Sequence(sequence::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::Position(data) => data.to_selection(),
                Self::SequenceId(data) => data.to_selection(),
                Self::BookId(data) => data.to_selection(),
                Self::Book(data) => data.to_selection(),
                Self::Sequence(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_book_sequence { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $crate :: prisma :: book_sequence :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = $crate :: prisma :: book_sequence :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: book_sequence :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: book_sequence :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: book_sequence :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: book_sequence :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: book_sequence :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: book_sequence :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { book , sequence } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : i32 , pub position : i32 , pub sequence_id : i32 , pub book_id : i32 , $ (pub $ field : crate :: prisma :: book_sequence :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (position) , stringify ! (sequence_id) , stringify ! (book_id)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: book_sequence :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: book_sequence :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: book_sequence :: position :: NAME , & self . position) ? ; state . serialize_field (crate :: prisma :: book_sequence :: sequence_id :: NAME , & self . sequence_id) ? ; state . serialize_field (crate :: prisma :: book_sequence :: book_id :: NAME , & self . book_id) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , position , sequence_id , book_id } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: book_sequence :: $ field :: NAME) , + , crate :: prisma :: book_sequence :: id :: NAME , crate :: prisma :: book_sequence :: position :: NAME , crate :: prisma :: book_sequence :: sequence_id :: NAME , crate :: prisma :: book_sequence :: book_id :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: book_sequence :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: book_sequence :: id :: NAME => Ok (Field :: id) , crate :: prisma :: book_sequence :: position :: NAME => Ok (Field :: position) , crate :: prisma :: book_sequence :: sequence_id :: NAME => Ok (Field :: sequence_id) , crate :: prisma :: book_sequence :: book_id :: NAME => Ok (Field :: book_id) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut position = None ; let mut sequence_id = None ; let mut book_id = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: book_sequence :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: position => { if position . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: book_sequence :: position :: NAME)) ; } position = Some (map . next_value () ?) ; } Field :: sequence_id => { if sequence_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: book_sequence :: sequence_id :: NAME)) ; } sequence_id = Some (map . next_value () ?) ; } Field :: book_id => { if book_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: book_sequence :: book_id :: NAME)) ; } book_id = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: book_sequence :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: book_sequence :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: book_sequence :: id :: NAME)) ? ; let position = position . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: book_sequence :: position :: NAME)) ? ; let sequence_id = sequence_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: book_sequence :: sequence_id :: NAME)) ? ; let book_id = book_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: book_sequence :: book_id :: NAME)) ? ; Ok (Data { id , position , sequence_id , book_id , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "position" , "sequence_id" , "book_id" , "book" , "sequence"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: book_sequence :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; book : $ selection_mode : ident { $ ($ selections : tt) + }) => { book :: Data } ; (@ field_type ; book) => { crate :: prisma :: book :: Data } ; (@ field_type ; sequence : $ selection_mode : ident { $ ($ selections : tt) + }) => { sequence :: Data } ; (@ field_type ; sequence) => { crate :: prisma :: sequence :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "BookSequence" , available relations are "book, sequence")) } ; (@ field_module ; book : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: book :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; sequence : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: sequence :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; book $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: book_sequence :: IncludeParam > :: into (crate :: prisma :: book_sequence :: book :: Include :: $ selection_mode (crate :: prisma :: book :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; book $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: book_sequence :: IncludeParam > :: into (crate :: prisma :: book_sequence :: book :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; sequence $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: book_sequence :: IncludeParam > :: into (crate :: prisma :: book_sequence :: sequence :: Include :: $ selection_mode (crate :: prisma :: sequence :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; sequence $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: book_sequence :: IncludeParam > :: into (crate :: prisma :: book_sequence :: sequence :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: book_sequence :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; position) => { "position" } ; (@ field_serde_name ; sequence_id) => { "sequence_id" } ; (@ field_serde_name ; book_id) => { "book_id" } ; (@ field_serde_name ; book) => { "book" } ; (@ field_serde_name ; sequence) => { "sequence" } ; }
    pub use _include_book_sequence as include;
    pub enum IncludeParam {
        Id(id::Include),
        Position(position::Include),
        SequenceId(sequence_id::Include),
        BookId(book_id::Include),
        Book(book::Include),
        Sequence(sequence::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::Position(data) => data.to_selection(),
                Self::SequenceId(data) => data.to_selection(),
                Self::BookId(data) => data.to_selection(),
                Self::Book(data) => data.to_selection(),
                Self::Sequence(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _partial_unchecked_book_sequence { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { $crate :: prisma :: book_sequence struct $ struct_name { # [serde (rename = "id")] pub id : i32 , # [serde (rename = "position")] pub position : i32 , # [serde (rename = "sequence_id")] pub sequence_id : i32 , # [serde (rename = "book_id")] pub book_id : i32 } [$ ($ scalar_field) , +] } } ; }
    pub use _partial_unchecked_book_sequence as partial_unchecked;
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: i32,
        #[serde(rename = "position")]
        pub position: i32,
        #[serde(rename = "sequence_id")]
        pub sequence_id: i32,
        #[serde(rename = "book_id")]
        pub book_id: i32,
        #[serde(rename = "book")]
        pub book: Option<Box<super::book::Data>>,
        #[serde(rename = "sequence")]
        pub sequence: Option<Box<super::sequence::Data>>,
    }
    impl Data {
        pub fn book(
            &self,
        ) -> Result<&super::book::Data, ::prisma_client_rust::RelationNotFetchedError> {
            self.book
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(book),
                ))
                .map(|v| v.as_ref())
        }
        pub fn sequence(
            &self,
        ) -> Result<&super::sequence::Data, ::prisma_client_rust::RelationNotFetchedError> {
            self.sequence
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(sequence),
                ))
                .map(|v| v.as_ref())
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        Book(super::book::UniqueArgs),
        Sequence(super::sequence::UniqueArgs),
    }
    impl From<WithParam> for ::prisma_client_rust::Selection {
        fn from(val: WithParam) -> Self {
            match val {
                WithParam::Book(args) => {
                    let mut selections =
                        <super::book::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                        );
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(book::NAME, None, [], selections)
                }
                WithParam::Sequence(args) => {
                    let mut selections = < super :: sequence :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(sequence::NAME, None, [], selections)
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(i32),
        IncrementId(i32),
        DecrementId(i32),
        MultiplyId(i32),
        DivideId(i32),
        SetPosition(i32),
        IncrementPosition(i32),
        DecrementPosition(i32),
        MultiplyPosition(i32),
        DividePosition(i32),
        SetSequenceId(i32),
        IncrementSequenceId(i32),
        DecrementSequenceId(i32),
        MultiplySequenceId(i32),
        DivideSequenceId(i32),
        SetBookId(i32),
        IncrementBookId(i32),
        DecrementBookId(i32),
        MultiplyBookId(i32),
        DivideBookId(i32),
        ConnectBook(super::book::UniqueWhereParam),
        ConnectSequence(super::sequence::UniqueWhereParam),
    }
    impl From<SetParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(param: SetParam) -> Self {
            match param {
                SetParam::SetId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetPosition(value) => (
                    position::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementPosition(value) => (
                    position::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementPosition(value) => (
                    position::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyPosition(value) => (
                    position::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DividePosition(value) => (
                    position::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetSequenceId(value) => (
                    sequence_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementSequenceId(value) => (
                    sequence_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementSequenceId(value) => (
                    sequence_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplySequenceId(value) => (
                    sequence_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideSequenceId(value) => (
                    sequence_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetBookId(value) => (
                    book_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementBookId(value) => (
                    book_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementBookId(value) => (
                    book_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyBookId(value) => (
                    book_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideBookId(value) => (
                    book_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::ConnectBook(where_param) => (
                    book::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::book::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectSequence(where_param) => (
                    sequence::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::sequence::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UncheckedSetParam {
        Id(i32),
        Position(i32),
        SequenceId(i32),
        BookId(i32),
    }
    impl From<UncheckedSetParam> for SetParam {
        fn from(param: UncheckedSetParam) -> Self {
            match param {
                UncheckedSetParam::Id(value) => Self::SetId(value),
                UncheckedSetParam::Position(value) => Self::SetPosition(value),
                UncheckedSetParam::SequenceId(value) => Self::SetSequenceId(value),
                UncheckedSetParam::BookId(value) => Self::SetBookId(value),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        Position(::prisma_client_rust::Direction),
        SequenceId(::prisma_client_rust::Direction),
        BookId(::prisma_client_rust::Direction),
    }
    impl From<OrderByParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(val: OrderByParam) -> Self {
            match val {
                OrderByParam::Id(direction) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                OrderByParam::Position(direction) => (
                    position::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                OrderByParam::SequenceId(direction) => (
                    sequence_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                OrderByParam::BookId(direction) => (
                    book_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        BookIdSequenceIdEquals(i32, i32),
        Id(_prisma::read_filters::IntFilter),
        Position(_prisma::read_filters::IntFilter),
        SequenceId(_prisma::read_filters::IntFilter),
        BookId(_prisma::read_filters::IntFilter),
        BookIs(Vec<super::book::WhereParam>),
        BookIsNot(Vec<super::book::WhereParam>),
        SequenceIs(Vec<super::sequence::WhereParam>),
        SequenceIsNot(Vec<super::sequence::WhereParam>),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::BookIdSequenceIdEquals(book_id, sequence_id) => (
                    "book_id_sequence_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![
                        (
                            book_id::NAME.to_string(),
                            ::prisma_client_rust::PrismaValue::Int(book_id as i64),
                        ),
                        (
                            sequence_id::NAME.to_string(),
                            ::prisma_client_rust::PrismaValue::Int(sequence_id as i64),
                        ),
                    ]),
                ),
                Self::Id(value) => (id::NAME, value.into()),
                Self::Position(value) => (position::NAME, value.into()),
                Self::SequenceId(value) => (sequence_id::NAME, value.into()),
                Self::BookId(value) => (book_id::NAME, value.into()),
                Self::BookIs(where_params) => (
                    book::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::BookIsNot(where_params) => (
                    book::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::SequenceIs(where_params) => (
                    sequence::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::SequenceIsNot(where_params) => (
                    sequence::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value)
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        BookIdSequenceIdEquals(i32, i32),
        IdEquals(i32),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::BookIdSequenceIdEquals(book_id, sequence_id) => {
                    Self::BookIdSequenceIdEquals(book_id, sequence_id)
                }
                UniqueWhereParam::IdEquals(value) => {
                    Self::Id(_prisma::read_filters::IntFilter::Equals(value))
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(id::NAME),
                ::prisma_client_rust::sel(position::NAME),
                ::prisma_client_rust::sel(sequence_id::NAME),
                ::prisma_client_rust::sel(book_id::NAME),
            ]
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            position: i32,
            book: super::book::UniqueWhereParam,
            sequence: super::sequence::UniqueWhereParam,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.extend([
                position::set(position),
                book::connect(book),
                sequence::connect(sequence),
            ]);
            Create::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            position: i32,
            sequence_id: i32,
            book_id: i32,
            mut _params: Vec<UncheckedSetParam>,
        ) -> Create<'a> {
            _params.extend([
                position::set(position),
                sequence_id::set(sequence_id),
                book_id::set(book_id),
            ]);
            Create::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn create_many(self, data: Vec<(i32, i32, i32, Vec<SetParam>)>) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(position, sequence_id, book_id, mut _params)| {
                    _params.extend([
                        position::set(position),
                        sequence_id::set(sequence_id),
                        book_id::set(book_id),
                    ]);
                    _params
                })
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> Update<'a> {
            Update::new(
                self.client,
                _where.into(),
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (position, book, sequence, mut _params): (
                i32,
                super::book::UniqueWhereParam,
                super::sequence::UniqueWhereParam,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.extend([
                position::set(position),
                book::connect(book),
                sequence::connect(sequence),
            ]);
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
        pub fn find_raw<T: ::prisma_client_rust::Data>(
            self,
        ) -> ::prisma_client_rust::FindRaw<'a, Types, T> {
            ::prisma_client_rust::FindRaw::new(self.client)
        }
        pub fn aggregate_raw<T: ::prisma_client_rust::Data>(
            self,
        ) -> ::prisma_client_rust::AggregateRaw<'a, Types, T> {
            ::prisma_client_rust::AggregateRaw::new(self.client)
        }
    }
}
pub mod book {
    
    use super::*;
    pub const NAME: &str = "Book";
    pub mod id {
        use super::super::*;
        
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam,
        };
        pub const NAME: &str = "id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Id, {
            fn in_vec(_: Vec<i32>) -> InVec;
            fn not_in_vec(_: Vec<i32>) -> NotInVec;
            fn lt(_: i32) -> Lt;
            fn lte(_: i32) -> Lte;
            fn gt(_: i32) -> Gt;
            fn gte(_: i32) -> Gte;
            fn not(_: i32) -> Not;
        });
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideId(value)
        }
        pub struct Include;
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::Id(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::Id(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod source_id {
        use super::super::*;
        
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "source_id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetSourceId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::SourceId(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::SourceId(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::SourceId(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntFilter,
            SourceId,
            {
                fn in_vec(_: Vec<i32>) -> InVec;
                fn not_in_vec(_: Vec<i32>) -> NotInVec;
                fn lt(_: i32) -> Lt;
                fn lte(_: i32) -> Lte;
                fn gt(_: i32) -> Gt;
                fn gte(_: i32) -> Gte;
                fn not(_: i32) -> Not;
            }
        );
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementSourceId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementSourceId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplySourceId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideSourceId(value)
        }
        pub struct Include;
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::SourceId(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::SourceId(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod remote_id {
        use super::super::*;
        
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "remote_id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetRemoteId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::RemoteId(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::RemoteId(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::RemoteId(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntFilter,
            RemoteId,
            {
                fn in_vec(_: Vec<i32>) -> InVec;
                fn not_in_vec(_: Vec<i32>) -> NotInVec;
                fn lt(_: i32) -> Lt;
                fn lte(_: i32) -> Lte;
                fn gt(_: i32) -> Gt;
                fn gte(_: i32) -> Gte;
                fn not(_: i32) -> Not;
            }
        );
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementRemoteId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementRemoteId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyRemoteId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideRemoteId(value)
        }
        pub struct Include;
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::RemoteId(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::RemoteId(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod title {
        use super::super::*;
        
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "title";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetTitle(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Title(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Title(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::Title(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            Title,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::Title(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::Title(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod lang {
        use super::super::*;
        
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "lang";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetLang(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Lang(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Lang(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::Lang(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::StringFilter, Lang, {
            fn in_vec(_: Vec<String>) -> InVec;
            fn not_in_vec(_: Vec<String>) -> NotInVec;
            fn lt(_: String) -> Lt;
            fn lte(_: String) -> Lte;
            fn gt(_: String) -> Gt;
            fn gte(_: String) -> Gte;
            fn contains(_: String) -> Contains;
            fn starts_with(_: String) -> StartsWith;
            fn ends_with(_: String) -> EndsWith;
            fn mode(_: super::super::QueryMode) -> Mode;
            fn not(_: String) -> Not;
        });
        pub struct Include;
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::Lang(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::Lang(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod file_type {
        use super::super::*;
        
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "file_type";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetFileType(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::FileType(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::FileType(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::FileType(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            FileType,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::FileType(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::FileType(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod uploaded {
        use super::super::*;
        
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "uploaded";
        pub struct Set(
            pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        );
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetUploaded(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Uploaded(v)
            }
        }
        pub fn set<T: From<Set>>(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Uploaded(direction)
        }
        pub fn equals(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::Uploaded(_prisma::read_filters::DateTimeFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::DateTimeFilter,
            Uploaded,
            {
                fn in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> InVec;
                fn not_in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> NotInVec;
                fn lt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lt;
                fn lte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lte;
                fn gt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gt;
                fn gte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gte;
                fn not(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Not;
            }
        );
        pub struct Include;
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::Uploaded(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::Uploaded(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod is_deleted {
        use super::super::*;
        
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "is_deleted";
        pub struct Set(pub bool);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetIsDeleted(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::IsDeleted(v)
            }
        }
        pub fn set<T: From<Set>>(value: bool) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::IsDeleted(direction)
        }
        pub fn equals(value: bool) -> WhereParam {
            WhereParam::IsDeleted(_prisma::read_filters::BoolFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::BoolFilter,
            IsDeleted,
            {
                fn not(_: bool) -> Not;
            }
        );
        pub struct Include;
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::IsDeleted(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::IsDeleted(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod pages {
        use super::super::*;
        
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "pages";
        pub struct Set(pub Option<i32>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetPages(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Pages(v)
            }
        }
        pub fn set<T: From<Set>>(value: Option<i32>) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Pages(direction)
        }
        pub fn equals(value: Option<i32>) -> WhereParam {
            WhereParam::Pages(_prisma::read_filters::IntNullableFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntNullableFilter,
            Pages,
            {
                fn in_vec(_: Vec<i32>) -> InVec;
                fn not_in_vec(_: Vec<i32>) -> NotInVec;
                fn lt(_: i32) -> Lt;
                fn lte(_: i32) -> Lte;
                fn gt(_: i32) -> Gt;
                fn gte(_: i32) -> Gte;
                fn not(_: Option<i32>) -> Not;
            }
        );
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementPages(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementPages(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyPages(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DividePages(value)
        }
        pub struct Include;
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::Pages(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::Pages(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod source {
        use super::super::*;
        
        use super::{
            SetParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "source";
        pub struct Fetch(pub source::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<source::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Source(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(source::UniqueArgs::new())
        }
        pub struct Connect(source::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectSource(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: source::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn is(value: Vec<source::WhereParam>) -> WhereParam {
            WhereParam::SourceIs(value)
        }
        pub fn is_not(value: Vec<source::WhereParam>) -> WhereParam {
            WhereParam::SourceIsNot(value)
        }
        pub enum Include {
            Select(Vec<source::SelectParam>),
            Include(Vec<source::IncludeParam>),
            Fetch,
        }
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::Source(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections =
                            <source::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                            );
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <source::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("source", None, [], selections)
            }
            pub fn select(nested_selections: Vec<source::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<source::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<source::SelectParam>),
            Include(Vec<source::IncludeParam>),
            Fetch,
        }
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::Source(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <source::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("source", None, [], selections)
            }
            pub fn select(nested_selections: Vec<source::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<source::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub mod book_annotation {
        use super::super::*;
        
        use super::{
            SetParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "book_annotation";
        pub struct Fetch(pub book_annotation::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<book_annotation::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::BookAnnotation(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(book_annotation::UniqueArgs::new())
        }
        pub struct Connect(book_annotation::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectBookAnnotation(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: book_annotation::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn disconnect() -> SetParam {
            SetParam::DisconnectBookAnnotation
        }
        pub fn is_null() -> WhereParam {
            WhereParam::BookAnnotationIsNull
        }
        pub fn is(value: Vec<book_annotation::WhereParam>) -> WhereParam {
            WhereParam::BookAnnotationIs(value)
        }
        pub fn is_not(value: Vec<book_annotation::WhereParam>) -> WhereParam {
            WhereParam::BookAnnotationIsNot(value)
        }
        pub enum Include {
            Select(Vec<book_annotation::SelectParam>),
            Include(Vec<book_annotation::IncludeParam>),
            Fetch,
        }
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::BookAnnotation(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self { Self :: Select (selections) => { selections . into_iter () . map (| s | s . to_selection ()) . collect () } , Self :: Include (selections) => { let mut nested_selections = < book_annotation :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections } , Self :: Fetch => { < book_annotation :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () } } ;
                ::prisma_client_rust::Selection::new("book_annotation", None, [], selections)
            }
            pub fn select(nested_selections: Vec<book_annotation::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<book_annotation::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<book_annotation::SelectParam>),
            Include(Vec<book_annotation::IncludeParam>),
            Fetch,
        }
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::BookAnnotation(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self { Self :: Select (selections) => { selections . into_iter () . map (| s | s . to_selection ()) . collect () } , Self :: Include (selections) => { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections } , Self :: Fetch => { < book_annotation :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () } } ;
                ::prisma_client_rust::Selection::new("book_annotation", None, [], selections)
            }
            pub fn select(nested_selections: Vec<book_annotation::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<book_annotation::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub mod book_authors {
        use super::super::*;
        
        use super::{
            SetParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "book_authors";
        pub struct Fetch(pub book_author::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<book_author::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: book_author::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: book_author::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value);
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::BookAuthors(v)
            }
        }
        pub fn fetch(params: Vec<book_author::WhereParam>) -> Fetch {
            Fetch(book_author::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<book_author::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectBookAuthors(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<book_author::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<book_author::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectBookAuthors(params)
        }
        pub fn set(params: Vec<book_author::UniqueWhereParam>) -> SetParam {
            SetParam::SetBookAuthors(params)
        }
        pub fn some(value: Vec<book_author::WhereParam>) -> WhereParam {
            WhereParam::BookAuthorsSome(value)
        }
        pub fn every(value: Vec<book_author::WhereParam>) -> WhereParam {
            WhereParam::BookAuthorsEvery(value)
        }
        pub fn none(value: Vec<book_author::WhereParam>) -> WhereParam {
            WhereParam::BookAuthorsNone(value)
        }
        pub enum Include {
            Select(book_author::ManyArgs, Vec<book_author::SelectParam>),
            Include(book_author::ManyArgs, Vec<book_author::IncludeParam>),
            Fetch(book_author::ManyArgs),
        }
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::BookAuthors(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections = < book_author :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <book_author::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                        ),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: book_author::ManyArgs,
                nested_selections: Vec<book_author::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: book_author::ManyArgs,
                nested_selections: Vec<book_author::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(book_author::ManyArgs, Vec<book_author::SelectParam>),
            Include(book_author::ManyArgs, Vec<book_author::IncludeParam>),
            Fetch(book_author::ManyArgs),
        }
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::BookAuthors(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <book_author::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                        ),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: book_author::ManyArgs,
                nested_selections: Vec<book_author::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: book_author::ManyArgs,
                nested_selections: Vec<book_author::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub mod book_genres {
        use super::super::*;
        
        use super::{
            SetParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "book_genres";
        pub struct Fetch(pub book_genre::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<book_genre::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: book_genre::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: book_genre::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value);
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::BookGenres(v)
            }
        }
        pub fn fetch(params: Vec<book_genre::WhereParam>) -> Fetch {
            Fetch(book_genre::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<book_genre::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectBookGenres(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<book_genre::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<book_genre::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectBookGenres(params)
        }
        pub fn set(params: Vec<book_genre::UniqueWhereParam>) -> SetParam {
            SetParam::SetBookGenres(params)
        }
        pub fn some(value: Vec<book_genre::WhereParam>) -> WhereParam {
            WhereParam::BookGenresSome(value)
        }
        pub fn every(value: Vec<book_genre::WhereParam>) -> WhereParam {
            WhereParam::BookGenresEvery(value)
        }
        pub fn none(value: Vec<book_genre::WhereParam>) -> WhereParam {
            WhereParam::BookGenresNone(value)
        }
        pub enum Include {
            Select(book_genre::ManyArgs, Vec<book_genre::SelectParam>),
            Include(book_genre::ManyArgs, Vec<book_genre::IncludeParam>),
            Fetch(book_genre::ManyArgs),
        }
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::BookGenres(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections = < book_genre :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <book_genre::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                        ),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: book_genre::ManyArgs,
                nested_selections: Vec<book_genre::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: book_genre::ManyArgs,
                nested_selections: Vec<book_genre::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(book_genre::ManyArgs, Vec<book_genre::SelectParam>),
            Include(book_genre::ManyArgs, Vec<book_genre::IncludeParam>),
            Fetch(book_genre::ManyArgs),
        }
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::BookGenres(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <book_genre::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                        ),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: book_genre::ManyArgs,
                nested_selections: Vec<book_genre::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: book_genre::ManyArgs,
                nested_selections: Vec<book_genre::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub mod book_sequences {
        use super::super::*;
        
        use super::{
            SetParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "book_sequences";
        pub struct Fetch(pub book_sequence::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<book_sequence::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: book_sequence::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: book_sequence::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value);
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::BookSequences(v)
            }
        }
        pub fn fetch(params: Vec<book_sequence::WhereParam>) -> Fetch {
            Fetch(book_sequence::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<book_sequence::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectBookSequences(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<book_sequence::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<book_sequence::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectBookSequences(params)
        }
        pub fn set(params: Vec<book_sequence::UniqueWhereParam>) -> SetParam {
            SetParam::SetBookSequences(params)
        }
        pub fn some(value: Vec<book_sequence::WhereParam>) -> WhereParam {
            WhereParam::BookSequencesSome(value)
        }
        pub fn every(value: Vec<book_sequence::WhereParam>) -> WhereParam {
            WhereParam::BookSequencesEvery(value)
        }
        pub fn none(value: Vec<book_sequence::WhereParam>) -> WhereParam {
            WhereParam::BookSequencesNone(value)
        }
        pub enum Include {
            Select(book_sequence::ManyArgs, Vec<book_sequence::SelectParam>),
            Include(book_sequence::ManyArgs, Vec<book_sequence::IncludeParam>),
            Fetch(book_sequence::ManyArgs),
        }
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::BookSequences(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = < book_sequence :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < book_sequence :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: book_sequence::ManyArgs,
                nested_selections: Vec<book_sequence::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: book_sequence::ManyArgs,
                nested_selections: Vec<book_sequence::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(book_sequence::ManyArgs, Vec<book_sequence::SelectParam>),
            Include(book_sequence::ManyArgs, Vec<book_sequence::IncludeParam>),
            Fetch(book_sequence::ManyArgs),
        }
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::BookSequences(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < book_sequence :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: book_sequence::ManyArgs,
                nested_selections: Vec<book_sequence::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: book_sequence::ManyArgs,
                nested_selections: Vec<book_sequence::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub mod translations {
        use super::super::*;
        
        use super::{
            SetParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "translations";
        pub struct Fetch(pub translator::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<translator::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: translator::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: translator::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value);
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Translations(v)
            }
        }
        pub fn fetch(params: Vec<translator::WhereParam>) -> Fetch {
            Fetch(translator::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<translator::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectTranslations(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<translator::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<translator::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectTranslations(params)
        }
        pub fn set(params: Vec<translator::UniqueWhereParam>) -> SetParam {
            SetParam::SetTranslations(params)
        }
        pub fn some(value: Vec<translator::WhereParam>) -> WhereParam {
            WhereParam::TranslationsSome(value)
        }
        pub fn every(value: Vec<translator::WhereParam>) -> WhereParam {
            WhereParam::TranslationsEvery(value)
        }
        pub fn none(value: Vec<translator::WhereParam>) -> WhereParam {
            WhereParam::TranslationsNone(value)
        }
        pub enum Include {
            Select(translator::ManyArgs, Vec<translator::SelectParam>),
            Include(translator::ManyArgs, Vec<translator::IncludeParam>),
            Fetch(translator::ManyArgs),
        }
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::Translations(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections = < translator :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <translator::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                        ),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: translator::ManyArgs,
                nested_selections: Vec<translator::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: translator::ManyArgs,
                nested_selections: Vec<translator::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(translator::ManyArgs, Vec<translator::SelectParam>),
            Include(translator::ManyArgs, Vec<translator::IncludeParam>),
            Fetch(translator::ManyArgs),
        }
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::Translations(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <translator::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                        ),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: translator::ManyArgs,
                nested_selections: Vec<translator::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: translator::ManyArgs,
                nested_selections: Vec<translator::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub fn source_id_remote_id<T: From<UniqueWhereParam>>(source_id: i32, remote_id: i32) -> T {
        UniqueWhereParam::SourceIdRemoteIdEquals(source_id, remote_id).into()
    }
    pub fn create(
        remote_id: i32,
        title: String,
        lang: String,
        file_type: String,
        uploaded: ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        source: super::source::UniqueWhereParam,
        _params: Vec<SetParam>,
    ) -> (
        i32,
        String,
        String,
        String,
        ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        super::source::UniqueWhereParam,
        Vec<SetParam>,
    ) {
        (remote_id, title, lang, file_type, uploaded, source, _params)
    }
    pub fn create_unchecked(
        source_id: i32,
        remote_id: i32,
        title: String,
        lang: String,
        file_type: String,
        uploaded: ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        _params: Vec<SetParam>,
    ) -> (
        i32,
        i32,
        String,
        String,
        String,
        ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        Vec<SetParam>,
    ) {
        (
            source_id, remote_id, title, lang, file_type, uploaded, _params,
        )
    }
    #[macro_export]
    macro_rules ! _select_book { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $crate :: prisma :: book :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = $crate :: prisma :: book :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: book :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: book :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: book :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: book :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , source_id , remote_id , title , lang , file_type , uploaded , is_deleted , pages , source , book_annotation , book_authors , book_genres , book_sequences , translations } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : crate :: prisma :: book :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: book :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: book :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: book :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: book :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: book :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "source_id" , "remote_id" , "title" , "lang" , "file_type" , "uploaded" , "is_deleted" , "pages" , "source" , "book_annotation" , "book_authors" , "book_genres" , "book_sequences" , "translations"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: book :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i32 } ; (@ field_type ; source_id) => { i32 } ; (@ field_type ; remote_id) => { i32 } ; (@ field_type ; title) => { String } ; (@ field_type ; lang) => { String } ; (@ field_type ; file_type) => { String } ; (@ field_type ; uploaded) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; is_deleted) => { bool } ; (@ field_type ; pages) => { Option < i32 > } ; (@ field_type ; source : $ selection_mode : ident { $ ($ selections : tt) + }) => { source :: Data } ; (@ field_type ; source) => { crate :: prisma :: source :: Data } ; (@ field_type ; book_annotation : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < book_annotation :: Data > } ; (@ field_type ; book_annotation) => { Option < crate :: prisma :: book_annotation :: Data > } ; (@ field_type ; book_authors : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < book_authors :: Data > } ; (@ field_type ; book_authors) => { Vec < crate :: prisma :: book_author :: Data > } ; (@ field_type ; book_genres : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < book_genres :: Data > } ; (@ field_type ; book_genres) => { Vec < crate :: prisma :: book_genre :: Data > } ; (@ field_type ; book_sequences : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < book_sequences :: Data > } ; (@ field_type ; book_sequences) => { Vec < crate :: prisma :: book_sequence :: Data > } ; (@ field_type ; translations : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < translations :: Data > } ; (@ field_type ; translations) => { Vec < crate :: prisma :: translator :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Book" , available relations are "id, source_id, remote_id, title, lang, file_type, uploaded, is_deleted, pages, source, book_annotation, book_authors, book_genres, book_sequences, translations")) } ; (@ field_module ; source : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: source :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; book_annotation : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: book_annotation :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; book_authors : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: book_author :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; book_genres : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: book_genre :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; book_sequences : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: book_sequence :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; translations : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: translator :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: book :: SelectParam > :: into (crate :: prisma :: book :: id :: Select) } ; (@ selection_field_to_selection_param ; source_id) => { Into :: < crate :: prisma :: book :: SelectParam > :: into (crate :: prisma :: book :: source_id :: Select) } ; (@ selection_field_to_selection_param ; remote_id) => { Into :: < crate :: prisma :: book :: SelectParam > :: into (crate :: prisma :: book :: remote_id :: Select) } ; (@ selection_field_to_selection_param ; title) => { Into :: < crate :: prisma :: book :: SelectParam > :: into (crate :: prisma :: book :: title :: Select) } ; (@ selection_field_to_selection_param ; lang) => { Into :: < crate :: prisma :: book :: SelectParam > :: into (crate :: prisma :: book :: lang :: Select) } ; (@ selection_field_to_selection_param ; file_type) => { Into :: < crate :: prisma :: book :: SelectParam > :: into (crate :: prisma :: book :: file_type :: Select) } ; (@ selection_field_to_selection_param ; uploaded) => { Into :: < crate :: prisma :: book :: SelectParam > :: into (crate :: prisma :: book :: uploaded :: Select) } ; (@ selection_field_to_selection_param ; is_deleted) => { Into :: < crate :: prisma :: book :: SelectParam > :: into (crate :: prisma :: book :: is_deleted :: Select) } ; (@ selection_field_to_selection_param ; pages) => { Into :: < crate :: prisma :: book :: SelectParam > :: into (crate :: prisma :: book :: pages :: Select) } ; (@ selection_field_to_selection_param ; source $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: book :: SelectParam > :: into (crate :: prisma :: book :: source :: Select :: $ selection_mode (crate :: prisma :: source :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; source $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: book :: SelectParam > :: into (crate :: prisma :: book :: source :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; book_annotation $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: book :: SelectParam > :: into (crate :: prisma :: book :: book_annotation :: Select :: $ selection_mode (crate :: prisma :: book_annotation :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; book_annotation $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: book :: SelectParam > :: into (crate :: prisma :: book :: book_annotation :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; book_authors $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: book :: SelectParam > :: into (crate :: prisma :: book :: book_authors :: Select :: $ selection_mode (crate :: prisma :: book_author :: ManyArgs :: new (crate :: prisma :: book_author :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: book_author :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; book_authors $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: book :: SelectParam > :: into (crate :: prisma :: book :: book_authors :: Select :: Fetch (crate :: prisma :: book_author :: ManyArgs :: new (crate :: prisma :: book_author :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; book_genres $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: book :: SelectParam > :: into (crate :: prisma :: book :: book_genres :: Select :: $ selection_mode (crate :: prisma :: book_genre :: ManyArgs :: new (crate :: prisma :: book_genre :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: book_genre :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; book_genres $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: book :: SelectParam > :: into (crate :: prisma :: book :: book_genres :: Select :: Fetch (crate :: prisma :: book_genre :: ManyArgs :: new (crate :: prisma :: book_genre :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; book_sequences $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: book :: SelectParam > :: into (crate :: prisma :: book :: book_sequences :: Select :: $ selection_mode (crate :: prisma :: book_sequence :: ManyArgs :: new (crate :: prisma :: book_sequence :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: book_sequence :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; book_sequences $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: book :: SelectParam > :: into (crate :: prisma :: book :: book_sequences :: Select :: Fetch (crate :: prisma :: book_sequence :: ManyArgs :: new (crate :: prisma :: book_sequence :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; translations $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: book :: SelectParam > :: into (crate :: prisma :: book :: translations :: Select :: $ selection_mode (crate :: prisma :: translator :: ManyArgs :: new (crate :: prisma :: translator :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: translator :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; translations $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: book :: SelectParam > :: into (crate :: prisma :: book :: translations :: Select :: Fetch (crate :: prisma :: translator :: ManyArgs :: new (crate :: prisma :: translator :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: book :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; source_id) => { "source_id" } ; (@ field_serde_name ; remote_id) => { "remote_id" } ; (@ field_serde_name ; title) => { "title" } ; (@ field_serde_name ; lang) => { "lang" } ; (@ field_serde_name ; file_type) => { "file_type" } ; (@ field_serde_name ; uploaded) => { "uploaded" } ; (@ field_serde_name ; is_deleted) => { "is_deleted" } ; (@ field_serde_name ; pages) => { "pages" } ; (@ field_serde_name ; source) => { "source" } ; (@ field_serde_name ; book_annotation) => { "book_annotation" } ; (@ field_serde_name ; book_authors) => { "book_authors" } ; (@ field_serde_name ; book_genres) => { "book_genres" } ; (@ field_serde_name ; book_sequences) => { "book_sequences" } ; (@ field_serde_name ; translations) => { "translations" } ; }
    pub use _select_book as select;
    pub enum SelectParam {
        Id(id::Select),
        SourceId(source_id::Select),
        RemoteId(remote_id::Select),
        Title(title::Select),
        Lang(lang::Select),
        FileType(file_type::Select),
        Uploaded(uploaded::Select),
        IsDeleted(is_deleted::Select),
        Pages(pages::Select),
        Source(source::Select),
        BookAnnotation(book_annotation::Select),
        BookAuthors(book_authors::Select),
        BookGenres(book_genres::Select),
        BookSequences(book_sequences::Select),
        Translations(translations::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::SourceId(data) => data.to_selection(),
                Self::RemoteId(data) => data.to_selection(),
                Self::Title(data) => data.to_selection(),
                Self::Lang(data) => data.to_selection(),
                Self::FileType(data) => data.to_selection(),
                Self::Uploaded(data) => data.to_selection(),
                Self::IsDeleted(data) => data.to_selection(),
                Self::Pages(data) => data.to_selection(),
                Self::Source(data) => data.to_selection(),
                Self::BookAnnotation(data) => data.to_selection(),
                Self::BookAuthors(data) => data.to_selection(),
                Self::BookGenres(data) => data.to_selection(),
                Self::BookSequences(data) => data.to_selection(),
                Self::Translations(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_book { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $crate :: prisma :: book :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = $crate :: prisma :: book :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: book :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: book :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: book :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: book :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: book :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: book :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { source , book_annotation , book_authors , book_genres , book_sequences , translations } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : i32 , pub source_id : i32 , pub remote_id : i32 , pub title : String , pub lang : String , pub file_type : String , pub uploaded : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , pub is_deleted : bool , pub pages : Option < i32 > , $ (pub $ field : crate :: prisma :: book :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (source_id) , stringify ! (remote_id) , stringify ! (title) , stringify ! (lang) , stringify ! (file_type) , stringify ! (uploaded) , stringify ! (is_deleted) , stringify ! (pages)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: book :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: book :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: book :: source_id :: NAME , & self . source_id) ? ; state . serialize_field (crate :: prisma :: book :: remote_id :: NAME , & self . remote_id) ? ; state . serialize_field (crate :: prisma :: book :: title :: NAME , & self . title) ? ; state . serialize_field (crate :: prisma :: book :: lang :: NAME , & self . lang) ? ; state . serialize_field (crate :: prisma :: book :: file_type :: NAME , & self . file_type) ? ; state . serialize_field (crate :: prisma :: book :: uploaded :: NAME , & self . uploaded) ? ; state . serialize_field (crate :: prisma :: book :: is_deleted :: NAME , & self . is_deleted) ? ; state . serialize_field (crate :: prisma :: book :: pages :: NAME , & self . pages) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , source_id , remote_id , title , lang , file_type , uploaded , is_deleted , pages } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: book :: $ field :: NAME) , + , crate :: prisma :: book :: id :: NAME , crate :: prisma :: book :: source_id :: NAME , crate :: prisma :: book :: remote_id :: NAME , crate :: prisma :: book :: title :: NAME , crate :: prisma :: book :: lang :: NAME , crate :: prisma :: book :: file_type :: NAME , crate :: prisma :: book :: uploaded :: NAME , crate :: prisma :: book :: is_deleted :: NAME , crate :: prisma :: book :: pages :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: book :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: book :: id :: NAME => Ok (Field :: id) , crate :: prisma :: book :: source_id :: NAME => Ok (Field :: source_id) , crate :: prisma :: book :: remote_id :: NAME => Ok (Field :: remote_id) , crate :: prisma :: book :: title :: NAME => Ok (Field :: title) , crate :: prisma :: book :: lang :: NAME => Ok (Field :: lang) , crate :: prisma :: book :: file_type :: NAME => Ok (Field :: file_type) , crate :: prisma :: book :: uploaded :: NAME => Ok (Field :: uploaded) , crate :: prisma :: book :: is_deleted :: NAME => Ok (Field :: is_deleted) , crate :: prisma :: book :: pages :: NAME => Ok (Field :: pages) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut source_id = None ; let mut remote_id = None ; let mut title = None ; let mut lang = None ; let mut file_type = None ; let mut uploaded = None ; let mut is_deleted = None ; let mut pages = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: book :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: source_id => { if source_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: book :: source_id :: NAME)) ; } source_id = Some (map . next_value () ?) ; } Field :: remote_id => { if remote_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: book :: remote_id :: NAME)) ; } remote_id = Some (map . next_value () ?) ; } Field :: title => { if title . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: book :: title :: NAME)) ; } title = Some (map . next_value () ?) ; } Field :: lang => { if lang . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: book :: lang :: NAME)) ; } lang = Some (map . next_value () ?) ; } Field :: file_type => { if file_type . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: book :: file_type :: NAME)) ; } file_type = Some (map . next_value () ?) ; } Field :: uploaded => { if uploaded . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: book :: uploaded :: NAME)) ; } uploaded = Some (map . next_value () ?) ; } Field :: is_deleted => { if is_deleted . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: book :: is_deleted :: NAME)) ; } is_deleted = Some (map . next_value () ?) ; } Field :: pages => { if pages . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: book :: pages :: NAME)) ; } pages = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: book :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: book :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: book :: id :: NAME)) ? ; let source_id = source_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: book :: source_id :: NAME)) ? ; let remote_id = remote_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: book :: remote_id :: NAME)) ? ; let title = title . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: book :: title :: NAME)) ? ; let lang = lang . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: book :: lang :: NAME)) ? ; let file_type = file_type . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: book :: file_type :: NAME)) ? ; let uploaded = uploaded . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: book :: uploaded :: NAME)) ? ; let is_deleted = is_deleted . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: book :: is_deleted :: NAME)) ? ; let pages = pages . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: book :: pages :: NAME)) ? ; Ok (Data { id , source_id , remote_id , title , lang , file_type , uploaded , is_deleted , pages , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "source_id" , "remote_id" , "title" , "lang" , "file_type" , "uploaded" , "is_deleted" , "pages" , "source" , "book_annotation" , "book_authors" , "book_genres" , "book_sequences" , "translations"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: book :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; source : $ selection_mode : ident { $ ($ selections : tt) + }) => { source :: Data } ; (@ field_type ; source) => { crate :: prisma :: source :: Data } ; (@ field_type ; book_annotation : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < book_annotation :: Data > } ; (@ field_type ; book_annotation) => { Option < crate :: prisma :: book_annotation :: Data > } ; (@ field_type ; book_authors : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < book_authors :: Data > } ; (@ field_type ; book_authors) => { Vec < crate :: prisma :: book_author :: Data > } ; (@ field_type ; book_genres : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < book_genres :: Data > } ; (@ field_type ; book_genres) => { Vec < crate :: prisma :: book_genre :: Data > } ; (@ field_type ; book_sequences : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < book_sequences :: Data > } ; (@ field_type ; book_sequences) => { Vec < crate :: prisma :: book_sequence :: Data > } ; (@ field_type ; translations : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < translations :: Data > } ; (@ field_type ; translations) => { Vec < crate :: prisma :: translator :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Book" , available relations are "source, book_annotation, book_authors, book_genres, book_sequences, translations")) } ; (@ field_module ; source : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: source :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; book_annotation : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: book_annotation :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; book_authors : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: book_author :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; book_genres : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: book_genre :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; book_sequences : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: book_sequence :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; translations : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: translator :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; source $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: book :: IncludeParam > :: into (crate :: prisma :: book :: source :: Include :: $ selection_mode (crate :: prisma :: source :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; source $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: book :: IncludeParam > :: into (crate :: prisma :: book :: source :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; book_annotation $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: book :: IncludeParam > :: into (crate :: prisma :: book :: book_annotation :: Include :: $ selection_mode (crate :: prisma :: book_annotation :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; book_annotation $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: book :: IncludeParam > :: into (crate :: prisma :: book :: book_annotation :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; book_authors $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: book :: IncludeParam > :: into (crate :: prisma :: book :: book_authors :: Include :: $ selection_mode (crate :: prisma :: book_author :: ManyArgs :: new (crate :: prisma :: book_author :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: book_author :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; book_authors $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: book :: IncludeParam > :: into (crate :: prisma :: book :: book_authors :: Include :: Fetch (crate :: prisma :: book_author :: ManyArgs :: new (crate :: prisma :: book_author :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; book_genres $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: book :: IncludeParam > :: into (crate :: prisma :: book :: book_genres :: Include :: $ selection_mode (crate :: prisma :: book_genre :: ManyArgs :: new (crate :: prisma :: book_genre :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: book_genre :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; book_genres $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: book :: IncludeParam > :: into (crate :: prisma :: book :: book_genres :: Include :: Fetch (crate :: prisma :: book_genre :: ManyArgs :: new (crate :: prisma :: book_genre :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; book_sequences $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: book :: IncludeParam > :: into (crate :: prisma :: book :: book_sequences :: Include :: $ selection_mode (crate :: prisma :: book_sequence :: ManyArgs :: new (crate :: prisma :: book_sequence :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: book_sequence :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; book_sequences $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: book :: IncludeParam > :: into (crate :: prisma :: book :: book_sequences :: Include :: Fetch (crate :: prisma :: book_sequence :: ManyArgs :: new (crate :: prisma :: book_sequence :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; translations $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: book :: IncludeParam > :: into (crate :: prisma :: book :: translations :: Include :: $ selection_mode (crate :: prisma :: translator :: ManyArgs :: new (crate :: prisma :: translator :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: translator :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; translations $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: book :: IncludeParam > :: into (crate :: prisma :: book :: translations :: Include :: Fetch (crate :: prisma :: translator :: ManyArgs :: new (crate :: prisma :: translator :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: book :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; source_id) => { "source_id" } ; (@ field_serde_name ; remote_id) => { "remote_id" } ; (@ field_serde_name ; title) => { "title" } ; (@ field_serde_name ; lang) => { "lang" } ; (@ field_serde_name ; file_type) => { "file_type" } ; (@ field_serde_name ; uploaded) => { "uploaded" } ; (@ field_serde_name ; is_deleted) => { "is_deleted" } ; (@ field_serde_name ; pages) => { "pages" } ; (@ field_serde_name ; source) => { "source" } ; (@ field_serde_name ; book_annotation) => { "book_annotation" } ; (@ field_serde_name ; book_authors) => { "book_authors" } ; (@ field_serde_name ; book_genres) => { "book_genres" } ; (@ field_serde_name ; book_sequences) => { "book_sequences" } ; (@ field_serde_name ; translations) => { "translations" } ; }
    pub use _include_book as include;
    pub enum IncludeParam {
        Id(id::Include),
        SourceId(source_id::Include),
        RemoteId(remote_id::Include),
        Title(title::Include),
        Lang(lang::Include),
        FileType(file_type::Include),
        Uploaded(uploaded::Include),
        IsDeleted(is_deleted::Include),
        Pages(pages::Include),
        Source(source::Include),
        BookAnnotation(book_annotation::Include),
        BookAuthors(book_authors::Include),
        BookGenres(book_genres::Include),
        BookSequences(book_sequences::Include),
        Translations(translations::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::SourceId(data) => data.to_selection(),
                Self::RemoteId(data) => data.to_selection(),
                Self::Title(data) => data.to_selection(),
                Self::Lang(data) => data.to_selection(),
                Self::FileType(data) => data.to_selection(),
                Self::Uploaded(data) => data.to_selection(),
                Self::IsDeleted(data) => data.to_selection(),
                Self::Pages(data) => data.to_selection(),
                Self::Source(data) => data.to_selection(),
                Self::BookAnnotation(data) => data.to_selection(),
                Self::BookAuthors(data) => data.to_selection(),
                Self::BookGenres(data) => data.to_selection(),
                Self::BookSequences(data) => data.to_selection(),
                Self::Translations(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _partial_unchecked_book { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { $crate :: prisma :: book struct $ struct_name { # [serde (rename = "id")] pub id : i32 , # [serde (rename = "source_id")] pub source_id : i32 , # [serde (rename = "remote_id")] pub remote_id : i32 , # [serde (rename = "title")] pub title : String , # [serde (rename = "lang")] pub lang : String , # [serde (rename = "file_type")] pub file_type : String , # [serde (rename = "uploaded")] pub uploaded : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , # [serde (rename = "is_deleted")] pub is_deleted : bool , # [serde (rename = "pages")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub pages : Option < i32 > } [$ ($ scalar_field) , +] } } ; }
    pub use _partial_unchecked_book as partial_unchecked;
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: i32,
        #[serde(rename = "source_id")]
        pub source_id: i32,
        #[serde(rename = "remote_id")]
        pub remote_id: i32,
        #[serde(rename = "title")]
        pub title: String,
        #[serde(rename = "lang")]
        pub lang: String,
        #[serde(rename = "file_type")]
        pub file_type: String,
        #[serde(rename = "uploaded")]
        pub uploaded:
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        #[serde(rename = "is_deleted")]
        pub is_deleted: bool,
        #[serde(rename = "pages")]
        pub pages: Option<i32>,
        #[serde(rename = "source")]
        pub source: Option<Box<super::source::Data>>,
        #[serde(
            rename = "book_annotation",
            default,
            skip_serializing_if = "Option::is_none",
            with = "prisma_client_rust::serde::double_option"
        )]
        pub book_annotation: Option<Option<Box<super::book_annotation::Data>>>,
        #[serde(rename = "book_authors")]
        pub book_authors: Option<Vec<super::book_author::Data>>,
        #[serde(rename = "book_genres")]
        pub book_genres: Option<Vec<super::book_genre::Data>>,
        #[serde(rename = "book_sequences")]
        pub book_sequences: Option<Vec<super::book_sequence::Data>>,
        #[serde(rename = "translations")]
        pub translations: Option<Vec<super::translator::Data>>,
    }
    impl Data {
        pub fn source(
            &self,
        ) -> Result<&super::source::Data, ::prisma_client_rust::RelationNotFetchedError> {
            self.source
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(source),
                ))
                .map(|v| v.as_ref())
        }
        pub fn book_annotation(
            &self,
        ) -> Result<
            Option<&super::book_annotation::Data>,
            ::prisma_client_rust::RelationNotFetchedError,
        > {
            self.book_annotation
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(book_annotation),
                ))
                .map(|v| v.as_ref().map(|v| v.as_ref()))
        }
        pub fn book_authors(
            &self,
        ) -> Result<&Vec<super::book_author::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.book_authors
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(book_authors),
                ))
        }
        pub fn book_genres(
            &self,
        ) -> Result<&Vec<super::book_genre::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.book_genres
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(book_genres),
                ))
        }
        pub fn book_sequences(
            &self,
        ) -> Result<&Vec<super::book_sequence::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.book_sequences
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(book_sequences),
                ))
        }
        pub fn translations(
            &self,
        ) -> Result<&Vec<super::translator::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.translations
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(translations),
                ))
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        Source(super::source::UniqueArgs),
        BookAnnotation(super::book_annotation::UniqueArgs),
        BookAuthors(super::book_author::ManyArgs),
        BookGenres(super::book_genre::ManyArgs),
        BookSequences(super::book_sequence::ManyArgs),
        Translations(super::translator::ManyArgs),
    }
    impl From<WithParam> for ::prisma_client_rust::Selection {
        fn from(val: WithParam) -> Self {
            match val {
                WithParam::Source(args) => {
                    let mut selections = < super :: source :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(source::NAME, None, [], selections)
                }
                WithParam::BookAnnotation(args) => {
                    let mut selections = < super :: book_annotation :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(
                        book_annotation::NAME,
                        None,
                        [],
                        selections,
                    )
                }
                WithParam::BookAuthors(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections . extend (< super :: book_author :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
                    ::prisma_client_rust::Selection::new(
                        book_authors::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
                WithParam::BookGenres(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections . extend (< super :: book_genre :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
                    ::prisma_client_rust::Selection::new(
                        book_genres::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
                WithParam::BookSequences(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections . extend (< super :: book_sequence :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
                    ::prisma_client_rust::Selection::new(
                        book_sequences::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
                WithParam::Translations(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections . extend (< super :: translator :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
                    ::prisma_client_rust::Selection::new(
                        translations::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(i32),
        IncrementId(i32),
        DecrementId(i32),
        MultiplyId(i32),
        DivideId(i32),
        SetSourceId(i32),
        IncrementSourceId(i32),
        DecrementSourceId(i32),
        MultiplySourceId(i32),
        DivideSourceId(i32),
        SetRemoteId(i32),
        IncrementRemoteId(i32),
        DecrementRemoteId(i32),
        MultiplyRemoteId(i32),
        DivideRemoteId(i32),
        SetTitle(String),
        SetLang(String),
        SetFileType(String),
        SetUploaded(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        SetIsDeleted(bool),
        SetPages(Option<i32>),
        IncrementPages(i32),
        DecrementPages(i32),
        MultiplyPages(i32),
        DividePages(i32),
        ConnectSource(super::source::UniqueWhereParam),
        ConnectBookAnnotation(super::book_annotation::UniqueWhereParam),
        DisconnectBookAnnotation,
        ConnectBookAuthors(Vec<super::book_author::UniqueWhereParam>),
        DisconnectBookAuthors(Vec<super::book_author::UniqueWhereParam>),
        SetBookAuthors(Vec<super::book_author::UniqueWhereParam>),
        ConnectBookGenres(Vec<super::book_genre::UniqueWhereParam>),
        DisconnectBookGenres(Vec<super::book_genre::UniqueWhereParam>),
        SetBookGenres(Vec<super::book_genre::UniqueWhereParam>),
        ConnectBookSequences(Vec<super::book_sequence::UniqueWhereParam>),
        DisconnectBookSequences(Vec<super::book_sequence::UniqueWhereParam>),
        SetBookSequences(Vec<super::book_sequence::UniqueWhereParam>),
        ConnectTranslations(Vec<super::translator::UniqueWhereParam>),
        DisconnectTranslations(Vec<super::translator::UniqueWhereParam>),
        SetTranslations(Vec<super::translator::UniqueWhereParam>),
    }
    impl From<SetParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(param: SetParam) -> Self {
            match param {
                SetParam::SetId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetSourceId(value) => (
                    source_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementSourceId(value) => (
                    source_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementSourceId(value) => (
                    source_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplySourceId(value) => (
                    source_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideSourceId(value) => (
                    source_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetRemoteId(value) => (
                    remote_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementRemoteId(value) => (
                    remote_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementRemoteId(value) => (
                    remote_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyRemoteId(value) => (
                    remote_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideRemoteId(value) => (
                    remote_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetTitle(value) => (
                    title::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetLang(value) => (
                    lang::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetFileType(value) => (
                    file_type::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetUploaded(value) => (
                    uploaded::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::DateTime(value),
                ),
                SetParam::SetIsDeleted(value) => (
                    is_deleted::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Boolean(value),
                ),
                SetParam::SetPages(value) => (
                    pages::NAME.to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::Int(value as i64))
                        .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::IncrementPages(value) => (
                    pages::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementPages(value) => (
                    pages::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyPages(value) => (
                    pages::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DividePages(value) => (
                    pages::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::ConnectSource(where_param) => (
                    source::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::source::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectBookAnnotation(where_param) => (
                    book_annotation::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::book_annotation::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectBookAnnotation => (
                    book_annotation::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::Boolean(true),
                    )]),
                ),
                SetParam::ConnectBookAuthors(where_params) => (
                    book_authors::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::book_author::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectBookAuthors(where_params) => (
                    book_authors::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::book_author::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetBookAuthors(where_params) => (
                    book_authors::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::book_author::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectBookGenres(where_params) => (
                    book_genres::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::book_genre::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectBookGenres(where_params) => (
                    book_genres::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::book_genre::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetBookGenres(where_params) => (
                    book_genres::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::book_genre::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectBookSequences(where_params) => (
                    book_sequences::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::book_sequence::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectBookSequences(where_params) => (
                    book_sequences::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::book_sequence::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetBookSequences(where_params) => (
                    book_sequences::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::book_sequence::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectTranslations(where_params) => (
                    translations::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::translator::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectTranslations(where_params) => (
                    translations::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::translator::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetTranslations(where_params) => (
                    translations::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::translator::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UncheckedSetParam {
        Id(i32),
        SourceId(i32),
        RemoteId(i32),
        Title(String),
        Lang(String),
        FileType(String),
        Uploaded(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
        IsDeleted(bool),
        Pages(Option<i32>),
    }
    impl From<UncheckedSetParam> for SetParam {
        fn from(param: UncheckedSetParam) -> Self {
            match param {
                UncheckedSetParam::Id(value) => Self::SetId(value),
                UncheckedSetParam::SourceId(value) => Self::SetSourceId(value),
                UncheckedSetParam::RemoteId(value) => Self::SetRemoteId(value),
                UncheckedSetParam::Title(value) => Self::SetTitle(value),
                UncheckedSetParam::Lang(value) => Self::SetLang(value),
                UncheckedSetParam::FileType(value) => Self::SetFileType(value),
                UncheckedSetParam::Uploaded(value) => Self::SetUploaded(value),
                UncheckedSetParam::IsDeleted(value) => Self::SetIsDeleted(value),
                UncheckedSetParam::Pages(value) => Self::SetPages(value),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        SourceId(::prisma_client_rust::Direction),
        RemoteId(::prisma_client_rust::Direction),
        Title(::prisma_client_rust::Direction),
        Lang(::prisma_client_rust::Direction),
        FileType(::prisma_client_rust::Direction),
        Uploaded(::prisma_client_rust::Direction),
        IsDeleted(::prisma_client_rust::Direction),
        Pages(::prisma_client_rust::Direction),
    }
    impl From<OrderByParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(val: OrderByParam) -> Self {
            match val {
                OrderByParam::Id(direction) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                OrderByParam::SourceId(direction) => (
                    source_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                OrderByParam::RemoteId(direction) => (
                    remote_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                OrderByParam::Title(direction) => (
                    title::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                OrderByParam::Lang(direction) => (
                    lang::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                OrderByParam::FileType(direction) => (
                    file_type::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                OrderByParam::Uploaded(direction) => (
                    uploaded::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                OrderByParam::IsDeleted(direction) => (
                    is_deleted::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                OrderByParam::Pages(direction) => (
                    pages::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        SourceIdRemoteIdEquals(i32, i32),
        Id(_prisma::read_filters::IntFilter),
        SourceId(_prisma::read_filters::IntFilter),
        RemoteId(_prisma::read_filters::IntFilter),
        Title(_prisma::read_filters::StringFilter),
        Lang(_prisma::read_filters::StringFilter),
        FileType(_prisma::read_filters::StringFilter),
        Uploaded(_prisma::read_filters::DateTimeFilter),
        IsDeleted(_prisma::read_filters::BoolFilter),
        Pages(_prisma::read_filters::IntNullableFilter),
        SourceIs(Vec<super::source::WhereParam>),
        SourceIsNot(Vec<super::source::WhereParam>),
        BookAnnotationIsNull,
        BookAnnotationIs(Vec<super::book_annotation::WhereParam>),
        BookAnnotationIsNot(Vec<super::book_annotation::WhereParam>),
        BookAuthorsSome(Vec<super::book_author::WhereParam>),
        BookAuthorsEvery(Vec<super::book_author::WhereParam>),
        BookAuthorsNone(Vec<super::book_author::WhereParam>),
        BookGenresSome(Vec<super::book_genre::WhereParam>),
        BookGenresEvery(Vec<super::book_genre::WhereParam>),
        BookGenresNone(Vec<super::book_genre::WhereParam>),
        BookSequencesSome(Vec<super::book_sequence::WhereParam>),
        BookSequencesEvery(Vec<super::book_sequence::WhereParam>),
        BookSequencesNone(Vec<super::book_sequence::WhereParam>),
        TranslationsSome(Vec<super::translator::WhereParam>),
        TranslationsEvery(Vec<super::translator::WhereParam>),
        TranslationsNone(Vec<super::translator::WhereParam>),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::SourceIdRemoteIdEquals(source_id, remote_id) => (
                    "source_id_remote_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![
                        (
                            source_id::NAME.to_string(),
                            ::prisma_client_rust::PrismaValue::Int(source_id as i64),
                        ),
                        (
                            remote_id::NAME.to_string(),
                            ::prisma_client_rust::PrismaValue::Int(remote_id as i64),
                        ),
                    ]),
                ),
                Self::Id(value) => (id::NAME, value.into()),
                Self::SourceId(value) => (source_id::NAME, value.into()),
                Self::RemoteId(value) => (remote_id::NAME, value.into()),
                Self::Title(value) => (title::NAME, value.into()),
                Self::Lang(value) => (lang::NAME, value.into()),
                Self::FileType(value) => (file_type::NAME, value.into()),
                Self::Uploaded(value) => (uploaded::NAME, value.into()),
                Self::IsDeleted(value) => (is_deleted::NAME, value.into()),
                Self::Pages(value) => (pages::NAME, value.into()),
                Self::SourceIs(where_params) => (
                    source::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::SourceIsNot(where_params) => (
                    source::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::BookAnnotationIsNull => (
                    book_annotation::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Value(
                        ::prisma_client_rust::PrismaValue::Null,
                    ),
                ),
                Self::BookAnnotationIs(where_params) => (
                    book_annotation::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::BookAnnotationIsNot(where_params) => (
                    book_annotation::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::BookAuthorsSome(where_params) => (
                    book_authors::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::BookAuthorsEvery(where_params) => (
                    book_authors::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::BookAuthorsNone(where_params) => (
                    book_authors::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::BookGenresSome(where_params) => (
                    book_genres::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::BookGenresEvery(where_params) => (
                    book_genres::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::BookGenresNone(where_params) => (
                    book_genres::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::BookSequencesSome(where_params) => (
                    book_sequences::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::BookSequencesEvery(where_params) => (
                    book_sequences::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::BookSequencesNone(where_params) => (
                    book_sequences::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::TranslationsSome(where_params) => (
                    translations::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::TranslationsEvery(where_params) => (
                    translations::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::TranslationsNone(where_params) => (
                    translations::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value)
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        SourceIdRemoteIdEquals(i32, i32),
        IdEquals(i32),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::SourceIdRemoteIdEquals(source_id, remote_id) => {
                    Self::SourceIdRemoteIdEquals(source_id, remote_id)
                }
                UniqueWhereParam::IdEquals(value) => {
                    Self::Id(_prisma::read_filters::IntFilter::Equals(value))
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(id::NAME),
                ::prisma_client_rust::sel(source_id::NAME),
                ::prisma_client_rust::sel(remote_id::NAME),
                ::prisma_client_rust::sel(title::NAME),
                ::prisma_client_rust::sel(lang::NAME),
                ::prisma_client_rust::sel(file_type::NAME),
                ::prisma_client_rust::sel(uploaded::NAME),
                ::prisma_client_rust::sel(is_deleted::NAME),
                ::prisma_client_rust::sel(pages::NAME),
            ]
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            remote_id: i32,
            title: String,
            lang: String,
            file_type: String,
            uploaded: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
            source: super::source::UniqueWhereParam,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.extend([
                remote_id::set(remote_id),
                title::set(title),
                lang::set(lang),
                file_type::set(file_type),
                uploaded::set(uploaded),
                source::connect(source),
            ]);
            Create::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            source_id: i32,
            remote_id: i32,
            title: String,
            lang: String,
            file_type: String,
            uploaded: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
            mut _params: Vec<UncheckedSetParam>,
        ) -> Create<'a> {
            _params.extend([
                source_id::set(source_id),
                remote_id::set(remote_id),
                title::set(title),
                lang::set(lang),
                file_type::set(file_type),
                uploaded::set(uploaded),
            ]);
            Create::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn create_many(
            self,
            data: Vec<(
                i32,
                i32,
                String,
                String,
                String,
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
                Vec<SetParam>,
            )>,
        ) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(
                    |(source_id, remote_id, title, lang, file_type, uploaded, mut _params)| {
                        _params.extend([
                            source_id::set(source_id),
                            remote_id::set(remote_id),
                            title::set(title),
                            lang::set(lang),
                            file_type::set(file_type),
                            uploaded::set(uploaded),
                        ]);
                        _params
                    },
                )
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> Update<'a> {
            Update::new(
                self.client,
                _where.into(),
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (remote_id, title, lang, file_type, uploaded, source, mut _params): (
                i32,
                String,
                String,
                String,
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
                super::source::UniqueWhereParam,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.extend([
                remote_id::set(remote_id),
                title::set(title),
                lang::set(lang),
                file_type::set(file_type),
                uploaded::set(uploaded),
                source::connect(source),
            ]);
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
        pub fn find_raw<T: ::prisma_client_rust::Data>(
            self,
        ) -> ::prisma_client_rust::FindRaw<'a, Types, T> {
            ::prisma_client_rust::FindRaw::new(self.client)
        }
        pub fn aggregate_raw<T: ::prisma_client_rust::Data>(
            self,
        ) -> ::prisma_client_rust::AggregateRaw<'a, Types, T> {
            ::prisma_client_rust::AggregateRaw::new(self.client)
        }
    }
}
pub mod genre {
    
    use super::*;
    pub const NAME: &str = "Genre";
    pub mod id {
        use super::super::*;
        
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam,
        };
        pub const NAME: &str = "id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Id, {
            fn in_vec(_: Vec<i32>) -> InVec;
            fn not_in_vec(_: Vec<i32>) -> NotInVec;
            fn lt(_: i32) -> Lt;
            fn lte(_: i32) -> Lte;
            fn gt(_: i32) -> Gt;
            fn gte(_: i32) -> Gte;
            fn not(_: i32) -> Not;
        });
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideId(value)
        }
        pub struct Include;
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::Id(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::Id(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod source_id {
        use super::super::*;
        
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "source_id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetSourceId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::SourceId(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::SourceId(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::SourceId(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntFilter,
            SourceId,
            {
                fn in_vec(_: Vec<i32>) -> InVec;
                fn not_in_vec(_: Vec<i32>) -> NotInVec;
                fn lt(_: i32) -> Lt;
                fn lte(_: i32) -> Lte;
                fn gt(_: i32) -> Gt;
                fn gte(_: i32) -> Gte;
                fn not(_: i32) -> Not;
            }
        );
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementSourceId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementSourceId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplySourceId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideSourceId(value)
        }
        pub struct Include;
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::SourceId(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::SourceId(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod remote_id {
        use super::super::*;
        
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "remote_id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetRemoteId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::RemoteId(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::RemoteId(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::RemoteId(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntFilter,
            RemoteId,
            {
                fn in_vec(_: Vec<i32>) -> InVec;
                fn not_in_vec(_: Vec<i32>) -> NotInVec;
                fn lt(_: i32) -> Lt;
                fn lte(_: i32) -> Lte;
                fn gt(_: i32) -> Gt;
                fn gte(_: i32) -> Gte;
                fn not(_: i32) -> Not;
            }
        );
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementRemoteId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementRemoteId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyRemoteId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideRemoteId(value)
        }
        pub struct Include;
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::RemoteId(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::RemoteId(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod code {
        use super::super::*;
        
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "code";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetCode(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Code(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Code(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::Code(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::StringFilter, Code, {
            fn in_vec(_: Vec<String>) -> InVec;
            fn not_in_vec(_: Vec<String>) -> NotInVec;
            fn lt(_: String) -> Lt;
            fn lte(_: String) -> Lte;
            fn gt(_: String) -> Gt;
            fn gte(_: String) -> Gte;
            fn contains(_: String) -> Contains;
            fn starts_with(_: String) -> StartsWith;
            fn ends_with(_: String) -> EndsWith;
            fn mode(_: super::super::QueryMode) -> Mode;
            fn not(_: String) -> Not;
        });
        pub struct Include;
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::Code(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::Code(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod description {
        use super::super::*;
        
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "description";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetDescription(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Description(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Description(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::Description(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            Description,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::Description(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::Description(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod meta {
        use super::super::*;
        
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "meta";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetMeta(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Meta(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Meta(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::Meta(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::StringFilter, Meta, {
            fn in_vec(_: Vec<String>) -> InVec;
            fn not_in_vec(_: Vec<String>) -> NotInVec;
            fn lt(_: String) -> Lt;
            fn lte(_: String) -> Lte;
            fn gt(_: String) -> Gt;
            fn gte(_: String) -> Gte;
            fn contains(_: String) -> Contains;
            fn starts_with(_: String) -> StartsWith;
            fn ends_with(_: String) -> EndsWith;
            fn mode(_: super::super::QueryMode) -> Mode;
            fn not(_: String) -> Not;
        });
        pub struct Include;
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::Meta(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::Meta(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod source {
        use super::super::*;
        
        use super::{
            SetParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "source";
        pub struct Fetch(pub source::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<source::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Source(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(source::UniqueArgs::new())
        }
        pub struct Connect(source::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectSource(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: source::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn is(value: Vec<source::WhereParam>) -> WhereParam {
            WhereParam::SourceIs(value)
        }
        pub fn is_not(value: Vec<source::WhereParam>) -> WhereParam {
            WhereParam::SourceIsNot(value)
        }
        pub enum Include {
            Select(Vec<source::SelectParam>),
            Include(Vec<source::IncludeParam>),
            Fetch,
        }
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::Source(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections =
                            <source::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                            );
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <source::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("source", None, [], selections)
            }
            pub fn select(nested_selections: Vec<source::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<source::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<source::SelectParam>),
            Include(Vec<source::IncludeParam>),
            Fetch,
        }
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::Source(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <source::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("source", None, [], selections)
            }
            pub fn select(nested_selections: Vec<source::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<source::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub mod book_genres {
        use super::super::*;
        
        use super::{
            SetParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "book_genres";
        pub struct Fetch(pub book_genre::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<book_genre::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: book_genre::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: book_genre::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value);
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::BookGenres(v)
            }
        }
        pub fn fetch(params: Vec<book_genre::WhereParam>) -> Fetch {
            Fetch(book_genre::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<book_genre::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectBookGenres(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<book_genre::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<book_genre::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectBookGenres(params)
        }
        pub fn set(params: Vec<book_genre::UniqueWhereParam>) -> SetParam {
            SetParam::SetBookGenres(params)
        }
        pub fn some(value: Vec<book_genre::WhereParam>) -> WhereParam {
            WhereParam::BookGenresSome(value)
        }
        pub fn every(value: Vec<book_genre::WhereParam>) -> WhereParam {
            WhereParam::BookGenresEvery(value)
        }
        pub fn none(value: Vec<book_genre::WhereParam>) -> WhereParam {
            WhereParam::BookGenresNone(value)
        }
        pub enum Include {
            Select(book_genre::ManyArgs, Vec<book_genre::SelectParam>),
            Include(book_genre::ManyArgs, Vec<book_genre::IncludeParam>),
            Fetch(book_genre::ManyArgs),
        }
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::BookGenres(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections = < book_genre :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <book_genre::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                        ),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: book_genre::ManyArgs,
                nested_selections: Vec<book_genre::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: book_genre::ManyArgs,
                nested_selections: Vec<book_genre::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(book_genre::ManyArgs, Vec<book_genre::SelectParam>),
            Include(book_genre::ManyArgs, Vec<book_genre::IncludeParam>),
            Fetch(book_genre::ManyArgs),
        }
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::BookGenres(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <book_genre::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                        ),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: book_genre::ManyArgs,
                nested_selections: Vec<book_genre::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: book_genre::ManyArgs,
                nested_selections: Vec<book_genre::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub fn source_id_remote_id<T: From<UniqueWhereParam>>(source_id: i32, remote_id: i32) -> T {
        UniqueWhereParam::SourceIdRemoteIdEquals(source_id, remote_id).into()
    }
    pub fn create(
        remote_id: i32,
        code: String,
        description: String,
        meta: String,
        source: super::source::UniqueWhereParam,
        _params: Vec<SetParam>,
    ) -> (
        i32,
        String,
        String,
        String,
        super::source::UniqueWhereParam,
        Vec<SetParam>,
    ) {
        (remote_id, code, description, meta, source, _params)
    }
    pub fn create_unchecked(
        source_id: i32,
        remote_id: i32,
        code: String,
        description: String,
        meta: String,
        _params: Vec<SetParam>,
    ) -> (i32, i32, String, String, String, Vec<SetParam>) {
        (source_id, remote_id, code, description, meta, _params)
    }
    #[macro_export]
    macro_rules ! _select_genre { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $crate :: prisma :: genre :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = $crate :: prisma :: genre :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: genre :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: genre :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: genre :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: genre :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , source_id , remote_id , code , description , meta , source , book_genres } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : crate :: prisma :: genre :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: genre :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: genre :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: genre :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: genre :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: genre :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "source_id" , "remote_id" , "code" , "description" , "meta" , "source" , "book_genres"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: genre :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i32 } ; (@ field_type ; source_id) => { i32 } ; (@ field_type ; remote_id) => { i32 } ; (@ field_type ; code) => { String } ; (@ field_type ; description) => { String } ; (@ field_type ; meta) => { String } ; (@ field_type ; source : $ selection_mode : ident { $ ($ selections : tt) + }) => { source :: Data } ; (@ field_type ; source) => { crate :: prisma :: source :: Data } ; (@ field_type ; book_genres : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < book_genres :: Data > } ; (@ field_type ; book_genres) => { Vec < crate :: prisma :: book_genre :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Genre" , available relations are "id, source_id, remote_id, code, description, meta, source, book_genres")) } ; (@ field_module ; source : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: source :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; book_genres : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: book_genre :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: genre :: SelectParam > :: into (crate :: prisma :: genre :: id :: Select) } ; (@ selection_field_to_selection_param ; source_id) => { Into :: < crate :: prisma :: genre :: SelectParam > :: into (crate :: prisma :: genre :: source_id :: Select) } ; (@ selection_field_to_selection_param ; remote_id) => { Into :: < crate :: prisma :: genre :: SelectParam > :: into (crate :: prisma :: genre :: remote_id :: Select) } ; (@ selection_field_to_selection_param ; code) => { Into :: < crate :: prisma :: genre :: SelectParam > :: into (crate :: prisma :: genre :: code :: Select) } ; (@ selection_field_to_selection_param ; description) => { Into :: < crate :: prisma :: genre :: SelectParam > :: into (crate :: prisma :: genre :: description :: Select) } ; (@ selection_field_to_selection_param ; meta) => { Into :: < crate :: prisma :: genre :: SelectParam > :: into (crate :: prisma :: genre :: meta :: Select) } ; (@ selection_field_to_selection_param ; source $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: genre :: SelectParam > :: into (crate :: prisma :: genre :: source :: Select :: $ selection_mode (crate :: prisma :: source :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; source $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: genre :: SelectParam > :: into (crate :: prisma :: genre :: source :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; book_genres $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: genre :: SelectParam > :: into (crate :: prisma :: genre :: book_genres :: Select :: $ selection_mode (crate :: prisma :: book_genre :: ManyArgs :: new (crate :: prisma :: book_genre :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: book_genre :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; book_genres $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: genre :: SelectParam > :: into (crate :: prisma :: genre :: book_genres :: Select :: Fetch (crate :: prisma :: book_genre :: ManyArgs :: new (crate :: prisma :: book_genre :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: genre :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; source_id) => { "source_id" } ; (@ field_serde_name ; remote_id) => { "remote_id" } ; (@ field_serde_name ; code) => { "code" } ; (@ field_serde_name ; description) => { "description" } ; (@ field_serde_name ; meta) => { "meta" } ; (@ field_serde_name ; source) => { "source" } ; (@ field_serde_name ; book_genres) => { "book_genres" } ; }
    pub use _select_genre as select;
    pub enum SelectParam {
        Id(id::Select),
        SourceId(source_id::Select),
        RemoteId(remote_id::Select),
        Code(code::Select),
        Description(description::Select),
        Meta(meta::Select),
        Source(source::Select),
        BookGenres(book_genres::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::SourceId(data) => data.to_selection(),
                Self::RemoteId(data) => data.to_selection(),
                Self::Code(data) => data.to_selection(),
                Self::Description(data) => data.to_selection(),
                Self::Meta(data) => data.to_selection(),
                Self::Source(data) => data.to_selection(),
                Self::BookGenres(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_genre { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $crate :: prisma :: genre :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = $crate :: prisma :: genre :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: genre :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: genre :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: genre :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: genre :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: genre :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: genre :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { source , book_genres } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : i32 , pub source_id : i32 , pub remote_id : i32 , pub code : String , pub description : String , pub meta : String , $ (pub $ field : crate :: prisma :: genre :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (source_id) , stringify ! (remote_id) , stringify ! (code) , stringify ! (description) , stringify ! (meta)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: genre :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: genre :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: genre :: source_id :: NAME , & self . source_id) ? ; state . serialize_field (crate :: prisma :: genre :: remote_id :: NAME , & self . remote_id) ? ; state . serialize_field (crate :: prisma :: genre :: code :: NAME , & self . code) ? ; state . serialize_field (crate :: prisma :: genre :: description :: NAME , & self . description) ? ; state . serialize_field (crate :: prisma :: genre :: meta :: NAME , & self . meta) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , source_id , remote_id , code , description , meta } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: genre :: $ field :: NAME) , + , crate :: prisma :: genre :: id :: NAME , crate :: prisma :: genre :: source_id :: NAME , crate :: prisma :: genre :: remote_id :: NAME , crate :: prisma :: genre :: code :: NAME , crate :: prisma :: genre :: description :: NAME , crate :: prisma :: genre :: meta :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: genre :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: genre :: id :: NAME => Ok (Field :: id) , crate :: prisma :: genre :: source_id :: NAME => Ok (Field :: source_id) , crate :: prisma :: genre :: remote_id :: NAME => Ok (Field :: remote_id) , crate :: prisma :: genre :: code :: NAME => Ok (Field :: code) , crate :: prisma :: genre :: description :: NAME => Ok (Field :: description) , crate :: prisma :: genre :: meta :: NAME => Ok (Field :: meta) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut source_id = None ; let mut remote_id = None ; let mut code = None ; let mut description = None ; let mut meta = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: genre :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: source_id => { if source_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: genre :: source_id :: NAME)) ; } source_id = Some (map . next_value () ?) ; } Field :: remote_id => { if remote_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: genre :: remote_id :: NAME)) ; } remote_id = Some (map . next_value () ?) ; } Field :: code => { if code . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: genre :: code :: NAME)) ; } code = Some (map . next_value () ?) ; } Field :: description => { if description . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: genre :: description :: NAME)) ; } description = Some (map . next_value () ?) ; } Field :: meta => { if meta . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: genre :: meta :: NAME)) ; } meta = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: genre :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: genre :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: genre :: id :: NAME)) ? ; let source_id = source_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: genre :: source_id :: NAME)) ? ; let remote_id = remote_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: genre :: remote_id :: NAME)) ? ; let code = code . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: genre :: code :: NAME)) ? ; let description = description . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: genre :: description :: NAME)) ? ; let meta = meta . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: genre :: meta :: NAME)) ? ; Ok (Data { id , source_id , remote_id , code , description , meta , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "source_id" , "remote_id" , "code" , "description" , "meta" , "source" , "book_genres"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: genre :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; source : $ selection_mode : ident { $ ($ selections : tt) + }) => { source :: Data } ; (@ field_type ; source) => { crate :: prisma :: source :: Data } ; (@ field_type ; book_genres : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < book_genres :: Data > } ; (@ field_type ; book_genres) => { Vec < crate :: prisma :: book_genre :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Genre" , available relations are "source, book_genres")) } ; (@ field_module ; source : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: source :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; book_genres : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: book_genre :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; source $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: genre :: IncludeParam > :: into (crate :: prisma :: genre :: source :: Include :: $ selection_mode (crate :: prisma :: source :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; source $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: genre :: IncludeParam > :: into (crate :: prisma :: genre :: source :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; book_genres $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: genre :: IncludeParam > :: into (crate :: prisma :: genre :: book_genres :: Include :: $ selection_mode (crate :: prisma :: book_genre :: ManyArgs :: new (crate :: prisma :: book_genre :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: book_genre :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; book_genres $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: genre :: IncludeParam > :: into (crate :: prisma :: genre :: book_genres :: Include :: Fetch (crate :: prisma :: book_genre :: ManyArgs :: new (crate :: prisma :: book_genre :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: genre :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; source_id) => { "source_id" } ; (@ field_serde_name ; remote_id) => { "remote_id" } ; (@ field_serde_name ; code) => { "code" } ; (@ field_serde_name ; description) => { "description" } ; (@ field_serde_name ; meta) => { "meta" } ; (@ field_serde_name ; source) => { "source" } ; (@ field_serde_name ; book_genres) => { "book_genres" } ; }
    pub use _include_genre as include;
    pub enum IncludeParam {
        Id(id::Include),
        SourceId(source_id::Include),
        RemoteId(remote_id::Include),
        Code(code::Include),
        Description(description::Include),
        Meta(meta::Include),
        Source(source::Include),
        BookGenres(book_genres::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::SourceId(data) => data.to_selection(),
                Self::RemoteId(data) => data.to_selection(),
                Self::Code(data) => data.to_selection(),
                Self::Description(data) => data.to_selection(),
                Self::Meta(data) => data.to_selection(),
                Self::Source(data) => data.to_selection(),
                Self::BookGenres(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _partial_unchecked_genre { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { $crate :: prisma :: genre struct $ struct_name { # [serde (rename = "id")] pub id : i32 , # [serde (rename = "source_id")] pub source_id : i32 , # [serde (rename = "remote_id")] pub remote_id : i32 , # [serde (rename = "code")] pub code : String , # [serde (rename = "description")] pub description : String , # [serde (rename = "meta")] pub meta : String } [$ ($ scalar_field) , +] } } ; }
    pub use _partial_unchecked_genre as partial_unchecked;
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: i32,
        #[serde(rename = "source_id")]
        pub source_id: i32,
        #[serde(rename = "remote_id")]
        pub remote_id: i32,
        #[serde(rename = "code")]
        pub code: String,
        #[serde(rename = "description")]
        pub description: String,
        #[serde(rename = "meta")]
        pub meta: String,
        #[serde(rename = "source")]
        pub source: Option<Box<super::source::Data>>,
        #[serde(rename = "book_genres")]
        pub book_genres: Option<Vec<super::book_genre::Data>>,
    }
    impl Data {
        pub fn source(
            &self,
        ) -> Result<&super::source::Data, ::prisma_client_rust::RelationNotFetchedError> {
            self.source
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(source),
                ))
                .map(|v| v.as_ref())
        }
        pub fn book_genres(
            &self,
        ) -> Result<&Vec<super::book_genre::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.book_genres
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(book_genres),
                ))
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        Source(super::source::UniqueArgs),
        BookGenres(super::book_genre::ManyArgs),
    }
    impl From<WithParam> for ::prisma_client_rust::Selection {
        fn from(val: WithParam) -> Self {
            match val {
                WithParam::Source(args) => {
                    let mut selections = < super :: source :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(source::NAME, None, [], selections)
                }
                WithParam::BookGenres(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections . extend (< super :: book_genre :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
                    ::prisma_client_rust::Selection::new(
                        book_genres::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(i32),
        IncrementId(i32),
        DecrementId(i32),
        MultiplyId(i32),
        DivideId(i32),
        SetSourceId(i32),
        IncrementSourceId(i32),
        DecrementSourceId(i32),
        MultiplySourceId(i32),
        DivideSourceId(i32),
        SetRemoteId(i32),
        IncrementRemoteId(i32),
        DecrementRemoteId(i32),
        MultiplyRemoteId(i32),
        DivideRemoteId(i32),
        SetCode(String),
        SetDescription(String),
        SetMeta(String),
        ConnectSource(super::source::UniqueWhereParam),
        ConnectBookGenres(Vec<super::book_genre::UniqueWhereParam>),
        DisconnectBookGenres(Vec<super::book_genre::UniqueWhereParam>),
        SetBookGenres(Vec<super::book_genre::UniqueWhereParam>),
    }
    impl From<SetParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(param: SetParam) -> Self {
            match param {
                SetParam::SetId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetSourceId(value) => (
                    source_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementSourceId(value) => (
                    source_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementSourceId(value) => (
                    source_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplySourceId(value) => (
                    source_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideSourceId(value) => (
                    source_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetRemoteId(value) => (
                    remote_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementRemoteId(value) => (
                    remote_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementRemoteId(value) => (
                    remote_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyRemoteId(value) => (
                    remote_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideRemoteId(value) => (
                    remote_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetCode(value) => (
                    code::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetDescription(value) => (
                    description::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetMeta(value) => (
                    meta::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::ConnectSource(where_param) => (
                    source::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::source::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectBookGenres(where_params) => (
                    book_genres::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::book_genre::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectBookGenres(where_params) => (
                    book_genres::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::book_genre::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetBookGenres(where_params) => (
                    book_genres::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::book_genre::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UncheckedSetParam {
        Id(i32),
        SourceId(i32),
        RemoteId(i32),
        Code(String),
        Description(String),
        Meta(String),
    }
    impl From<UncheckedSetParam> for SetParam {
        fn from(param: UncheckedSetParam) -> Self {
            match param {
                UncheckedSetParam::Id(value) => Self::SetId(value),
                UncheckedSetParam::SourceId(value) => Self::SetSourceId(value),
                UncheckedSetParam::RemoteId(value) => Self::SetRemoteId(value),
                UncheckedSetParam::Code(value) => Self::SetCode(value),
                UncheckedSetParam::Description(value) => Self::SetDescription(value),
                UncheckedSetParam::Meta(value) => Self::SetMeta(value),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        SourceId(::prisma_client_rust::Direction),
        RemoteId(::prisma_client_rust::Direction),
        Code(::prisma_client_rust::Direction),
        Description(::prisma_client_rust::Direction),
        Meta(::prisma_client_rust::Direction),
    }
    impl From<OrderByParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(val: OrderByParam) -> Self {
            match val {
                OrderByParam::Id(direction) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                OrderByParam::SourceId(direction) => (
                    source_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                OrderByParam::RemoteId(direction) => (
                    remote_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                OrderByParam::Code(direction) => (
                    code::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                OrderByParam::Description(direction) => (
                    description::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                OrderByParam::Meta(direction) => (
                    meta::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        SourceIdRemoteIdEquals(i32, i32),
        Id(_prisma::read_filters::IntFilter),
        SourceId(_prisma::read_filters::IntFilter),
        RemoteId(_prisma::read_filters::IntFilter),
        Code(_prisma::read_filters::StringFilter),
        Description(_prisma::read_filters::StringFilter),
        Meta(_prisma::read_filters::StringFilter),
        SourceIs(Vec<super::source::WhereParam>),
        SourceIsNot(Vec<super::source::WhereParam>),
        BookGenresSome(Vec<super::book_genre::WhereParam>),
        BookGenresEvery(Vec<super::book_genre::WhereParam>),
        BookGenresNone(Vec<super::book_genre::WhereParam>),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::SourceIdRemoteIdEquals(source_id, remote_id) => (
                    "source_id_remote_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![
                        (
                            source_id::NAME.to_string(),
                            ::prisma_client_rust::PrismaValue::Int(source_id as i64),
                        ),
                        (
                            remote_id::NAME.to_string(),
                            ::prisma_client_rust::PrismaValue::Int(remote_id as i64),
                        ),
                    ]),
                ),
                Self::Id(value) => (id::NAME, value.into()),
                Self::SourceId(value) => (source_id::NAME, value.into()),
                Self::RemoteId(value) => (remote_id::NAME, value.into()),
                Self::Code(value) => (code::NAME, value.into()),
                Self::Description(value) => (description::NAME, value.into()),
                Self::Meta(value) => (meta::NAME, value.into()),
                Self::SourceIs(where_params) => (
                    source::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::SourceIsNot(where_params) => (
                    source::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::BookGenresSome(where_params) => (
                    book_genres::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::BookGenresEvery(where_params) => (
                    book_genres::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::BookGenresNone(where_params) => (
                    book_genres::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value)
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        SourceIdRemoteIdEquals(i32, i32),
        IdEquals(i32),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::SourceIdRemoteIdEquals(source_id, remote_id) => {
                    Self::SourceIdRemoteIdEquals(source_id, remote_id)
                }
                UniqueWhereParam::IdEquals(value) => {
                    Self::Id(_prisma::read_filters::IntFilter::Equals(value))
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(id::NAME),
                ::prisma_client_rust::sel(source_id::NAME),
                ::prisma_client_rust::sel(remote_id::NAME),
                ::prisma_client_rust::sel(code::NAME),
                ::prisma_client_rust::sel(description::NAME),
                ::prisma_client_rust::sel(meta::NAME),
            ]
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            remote_id: i32,
            code: String,
            description: String,
            meta: String,
            source: super::source::UniqueWhereParam,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.extend([
                remote_id::set(remote_id),
                code::set(code),
                description::set(description),
                meta::set(meta),
                source::connect(source),
            ]);
            Create::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            source_id: i32,
            remote_id: i32,
            code: String,
            description: String,
            meta: String,
            mut _params: Vec<UncheckedSetParam>,
        ) -> Create<'a> {
            _params.extend([
                source_id::set(source_id),
                remote_id::set(remote_id),
                code::set(code),
                description::set(description),
                meta::set(meta),
            ]);
            Create::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn create_many(
            self,
            data: Vec<(i32, i32, String, String, String, Vec<SetParam>)>,
        ) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(
                    |(source_id, remote_id, code, description, meta, mut _params)| {
                        _params.extend([
                            source_id::set(source_id),
                            remote_id::set(remote_id),
                            code::set(code),
                            description::set(description),
                            meta::set(meta),
                        ]);
                        _params
                    },
                )
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> Update<'a> {
            Update::new(
                self.client,
                _where.into(),
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (remote_id, code, description, meta, source, mut _params): (
                i32,
                String,
                String,
                String,
                super::source::UniqueWhereParam,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.extend([
                remote_id::set(remote_id),
                code::set(code),
                description::set(description),
                meta::set(meta),
                source::connect(source),
            ]);
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
        pub fn find_raw<T: ::prisma_client_rust::Data>(
            self,
        ) -> ::prisma_client_rust::FindRaw<'a, Types, T> {
            ::prisma_client_rust::FindRaw::new(self.client)
        }
        pub fn aggregate_raw<T: ::prisma_client_rust::Data>(
            self,
        ) -> ::prisma_client_rust::AggregateRaw<'a, Types, T> {
            ::prisma_client_rust::AggregateRaw::new(self.client)
        }
    }
}
pub mod sequence {
    
    use super::*;
    pub const NAME: &str = "Sequence";
    pub mod id {
        use super::super::*;
        
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam,
        };
        pub const NAME: &str = "id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Id, {
            fn in_vec(_: Vec<i32>) -> InVec;
            fn not_in_vec(_: Vec<i32>) -> NotInVec;
            fn lt(_: i32) -> Lt;
            fn lte(_: i32) -> Lte;
            fn gt(_: i32) -> Gt;
            fn gte(_: i32) -> Gte;
            fn not(_: i32) -> Not;
        });
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideId(value)
        }
        pub struct Include;
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::Id(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::Id(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod source_id {
        use super::super::*;
        
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "source_id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetSourceId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::SourceId(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::SourceId(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::SourceId(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntFilter,
            SourceId,
            {
                fn in_vec(_: Vec<i32>) -> InVec;
                fn not_in_vec(_: Vec<i32>) -> NotInVec;
                fn lt(_: i32) -> Lt;
                fn lte(_: i32) -> Lte;
                fn gt(_: i32) -> Gt;
                fn gte(_: i32) -> Gte;
                fn not(_: i32) -> Not;
            }
        );
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementSourceId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementSourceId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplySourceId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideSourceId(value)
        }
        pub struct Include;
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::SourceId(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::SourceId(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod remote_id {
        use super::super::*;
        
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "remote_id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetRemoteId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::RemoteId(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::RemoteId(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::RemoteId(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntFilter,
            RemoteId,
            {
                fn in_vec(_: Vec<i32>) -> InVec;
                fn not_in_vec(_: Vec<i32>) -> NotInVec;
                fn lt(_: i32) -> Lt;
                fn lte(_: i32) -> Lte;
                fn gt(_: i32) -> Gt;
                fn gte(_: i32) -> Gte;
                fn not(_: i32) -> Not;
            }
        );
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementRemoteId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementRemoteId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyRemoteId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideRemoteId(value)
        }
        pub struct Include;
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::RemoteId(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::RemoteId(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod name {
        use super::super::*;
        
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "name";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetName(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Name(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Name(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::StringFilter, Name, {
            fn in_vec(_: Vec<String>) -> InVec;
            fn not_in_vec(_: Vec<String>) -> NotInVec;
            fn lt(_: String) -> Lt;
            fn lte(_: String) -> Lte;
            fn gt(_: String) -> Gt;
            fn gte(_: String) -> Gte;
            fn contains(_: String) -> Contains;
            fn starts_with(_: String) -> StartsWith;
            fn ends_with(_: String) -> EndsWith;
            fn mode(_: super::super::QueryMode) -> Mode;
            fn not(_: String) -> Not;
        });
        pub struct Include;
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::Name(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::Name(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod source {
        use super::super::*;
        
        use super::{
            SetParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "source";
        pub struct Fetch(pub source::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<source::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Source(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(source::UniqueArgs::new())
        }
        pub struct Connect(source::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectSource(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: source::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn is(value: Vec<source::WhereParam>) -> WhereParam {
            WhereParam::SourceIs(value)
        }
        pub fn is_not(value: Vec<source::WhereParam>) -> WhereParam {
            WhereParam::SourceIsNot(value)
        }
        pub enum Include {
            Select(Vec<source::SelectParam>),
            Include(Vec<source::IncludeParam>),
            Fetch,
        }
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::Source(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections =
                            <source::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                            );
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <source::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("source", None, [], selections)
            }
            pub fn select(nested_selections: Vec<source::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<source::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<source::SelectParam>),
            Include(Vec<source::IncludeParam>),
            Fetch,
        }
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::Source(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <source::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("source", None, [], selections)
            }
            pub fn select(nested_selections: Vec<source::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<source::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub mod book_sequences {
        use super::super::*;
        
        use super::{
            SetParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "book_sequences";
        pub struct Fetch(pub book_sequence::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<book_sequence::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: book_sequence::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: book_sequence::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value);
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::BookSequences(v)
            }
        }
        pub fn fetch(params: Vec<book_sequence::WhereParam>) -> Fetch {
            Fetch(book_sequence::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<book_sequence::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectBookSequences(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<book_sequence::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<book_sequence::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectBookSequences(params)
        }
        pub fn set(params: Vec<book_sequence::UniqueWhereParam>) -> SetParam {
            SetParam::SetBookSequences(params)
        }
        pub fn some(value: Vec<book_sequence::WhereParam>) -> WhereParam {
            WhereParam::BookSequencesSome(value)
        }
        pub fn every(value: Vec<book_sequence::WhereParam>) -> WhereParam {
            WhereParam::BookSequencesEvery(value)
        }
        pub fn none(value: Vec<book_sequence::WhereParam>) -> WhereParam {
            WhereParam::BookSequencesNone(value)
        }
        pub enum Include {
            Select(book_sequence::ManyArgs, Vec<book_sequence::SelectParam>),
            Include(book_sequence::ManyArgs, Vec<book_sequence::IncludeParam>),
            Fetch(book_sequence::ManyArgs),
        }
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::BookSequences(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = < book_sequence :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < book_sequence :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: book_sequence::ManyArgs,
                nested_selections: Vec<book_sequence::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: book_sequence::ManyArgs,
                nested_selections: Vec<book_sequence::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(book_sequence::ManyArgs, Vec<book_sequence::SelectParam>),
            Include(book_sequence::ManyArgs, Vec<book_sequence::IncludeParam>),
            Fetch(book_sequence::ManyArgs),
        }
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::BookSequences(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < book_sequence :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: book_sequence::ManyArgs,
                nested_selections: Vec<book_sequence::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: book_sequence::ManyArgs,
                nested_selections: Vec<book_sequence::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub fn source_id_remote_id<T: From<UniqueWhereParam>>(source_id: i32, remote_id: i32) -> T {
        UniqueWhereParam::SourceIdRemoteIdEquals(source_id, remote_id).into()
    }
    pub fn create(
        remote_id: i32,
        name: String,
        source: super::source::UniqueWhereParam,
        _params: Vec<SetParam>,
    ) -> (i32, String, super::source::UniqueWhereParam, Vec<SetParam>) {
        (remote_id, name, source, _params)
    }
    pub fn create_unchecked(
        source_id: i32,
        remote_id: i32,
        name: String,
        _params: Vec<SetParam>,
    ) -> (i32, i32, String, Vec<SetParam>) {
        (source_id, remote_id, name, _params)
    }
    #[macro_export]
    macro_rules ! _select_sequence { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $crate :: prisma :: sequence :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = $crate :: prisma :: sequence :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: sequence :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: sequence :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: sequence :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: sequence :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , source_id , remote_id , name , source , book_sequences } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : crate :: prisma :: sequence :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: sequence :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: sequence :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: sequence :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: sequence :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: sequence :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "source_id" , "remote_id" , "name" , "source" , "book_sequences"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: sequence :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i32 } ; (@ field_type ; source_id) => { i32 } ; (@ field_type ; remote_id) => { i32 } ; (@ field_type ; name) => { String } ; (@ field_type ; source : $ selection_mode : ident { $ ($ selections : tt) + }) => { source :: Data } ; (@ field_type ; source) => { crate :: prisma :: source :: Data } ; (@ field_type ; book_sequences : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < book_sequences :: Data > } ; (@ field_type ; book_sequences) => { Vec < crate :: prisma :: book_sequence :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Sequence" , available relations are "id, source_id, remote_id, name, source, book_sequences")) } ; (@ field_module ; source : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: source :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; book_sequences : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: book_sequence :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: sequence :: SelectParam > :: into (crate :: prisma :: sequence :: id :: Select) } ; (@ selection_field_to_selection_param ; source_id) => { Into :: < crate :: prisma :: sequence :: SelectParam > :: into (crate :: prisma :: sequence :: source_id :: Select) } ; (@ selection_field_to_selection_param ; remote_id) => { Into :: < crate :: prisma :: sequence :: SelectParam > :: into (crate :: prisma :: sequence :: remote_id :: Select) } ; (@ selection_field_to_selection_param ; name) => { Into :: < crate :: prisma :: sequence :: SelectParam > :: into (crate :: prisma :: sequence :: name :: Select) } ; (@ selection_field_to_selection_param ; source $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: sequence :: SelectParam > :: into (crate :: prisma :: sequence :: source :: Select :: $ selection_mode (crate :: prisma :: source :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; source $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: sequence :: SelectParam > :: into (crate :: prisma :: sequence :: source :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; book_sequences $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: sequence :: SelectParam > :: into (crate :: prisma :: sequence :: book_sequences :: Select :: $ selection_mode (crate :: prisma :: book_sequence :: ManyArgs :: new (crate :: prisma :: book_sequence :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: book_sequence :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; book_sequences $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: sequence :: SelectParam > :: into (crate :: prisma :: sequence :: book_sequences :: Select :: Fetch (crate :: prisma :: book_sequence :: ManyArgs :: new (crate :: prisma :: book_sequence :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: sequence :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; source_id) => { "source_id" } ; (@ field_serde_name ; remote_id) => { "remote_id" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; source) => { "source" } ; (@ field_serde_name ; book_sequences) => { "book_sequences" } ; }
    pub use _select_sequence as select;
    pub enum SelectParam {
        Id(id::Select),
        SourceId(source_id::Select),
        RemoteId(remote_id::Select),
        Name(name::Select),
        Source(source::Select),
        BookSequences(book_sequences::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::SourceId(data) => data.to_selection(),
                Self::RemoteId(data) => data.to_selection(),
                Self::Name(data) => data.to_selection(),
                Self::Source(data) => data.to_selection(),
                Self::BookSequences(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_sequence { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $crate :: prisma :: sequence :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = $crate :: prisma :: sequence :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: sequence :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: sequence :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: sequence :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: sequence :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: sequence :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: sequence :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { source , book_sequences } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : i32 , pub source_id : i32 , pub remote_id : i32 , pub name : String , $ (pub $ field : crate :: prisma :: sequence :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (source_id) , stringify ! (remote_id) , stringify ! (name)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: sequence :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: sequence :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: sequence :: source_id :: NAME , & self . source_id) ? ; state . serialize_field (crate :: prisma :: sequence :: remote_id :: NAME , & self . remote_id) ? ; state . serialize_field (crate :: prisma :: sequence :: name :: NAME , & self . name) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , source_id , remote_id , name } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: sequence :: $ field :: NAME) , + , crate :: prisma :: sequence :: id :: NAME , crate :: prisma :: sequence :: source_id :: NAME , crate :: prisma :: sequence :: remote_id :: NAME , crate :: prisma :: sequence :: name :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: sequence :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: sequence :: id :: NAME => Ok (Field :: id) , crate :: prisma :: sequence :: source_id :: NAME => Ok (Field :: source_id) , crate :: prisma :: sequence :: remote_id :: NAME => Ok (Field :: remote_id) , crate :: prisma :: sequence :: name :: NAME => Ok (Field :: name) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut source_id = None ; let mut remote_id = None ; let mut name = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: sequence :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: source_id => { if source_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: sequence :: source_id :: NAME)) ; } source_id = Some (map . next_value () ?) ; } Field :: remote_id => { if remote_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: sequence :: remote_id :: NAME)) ; } remote_id = Some (map . next_value () ?) ; } Field :: name => { if name . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: sequence :: name :: NAME)) ; } name = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: sequence :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: sequence :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: sequence :: id :: NAME)) ? ; let source_id = source_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: sequence :: source_id :: NAME)) ? ; let remote_id = remote_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: sequence :: remote_id :: NAME)) ? ; let name = name . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: sequence :: name :: NAME)) ? ; Ok (Data { id , source_id , remote_id , name , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "source_id" , "remote_id" , "name" , "source" , "book_sequences"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: sequence :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; source : $ selection_mode : ident { $ ($ selections : tt) + }) => { source :: Data } ; (@ field_type ; source) => { crate :: prisma :: source :: Data } ; (@ field_type ; book_sequences : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < book_sequences :: Data > } ; (@ field_type ; book_sequences) => { Vec < crate :: prisma :: book_sequence :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Sequence" , available relations are "source, book_sequences")) } ; (@ field_module ; source : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: source :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; book_sequences : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: book_sequence :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; source $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: sequence :: IncludeParam > :: into (crate :: prisma :: sequence :: source :: Include :: $ selection_mode (crate :: prisma :: source :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; source $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: sequence :: IncludeParam > :: into (crate :: prisma :: sequence :: source :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; book_sequences $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: sequence :: IncludeParam > :: into (crate :: prisma :: sequence :: book_sequences :: Include :: $ selection_mode (crate :: prisma :: book_sequence :: ManyArgs :: new (crate :: prisma :: book_sequence :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: book_sequence :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; book_sequences $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: sequence :: IncludeParam > :: into (crate :: prisma :: sequence :: book_sequences :: Include :: Fetch (crate :: prisma :: book_sequence :: ManyArgs :: new (crate :: prisma :: book_sequence :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: sequence :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; source_id) => { "source_id" } ; (@ field_serde_name ; remote_id) => { "remote_id" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; source) => { "source" } ; (@ field_serde_name ; book_sequences) => { "book_sequences" } ; }
    pub use _include_sequence as include;
    pub enum IncludeParam {
        Id(id::Include),
        SourceId(source_id::Include),
        RemoteId(remote_id::Include),
        Name(name::Include),
        Source(source::Include),
        BookSequences(book_sequences::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::SourceId(data) => data.to_selection(),
                Self::RemoteId(data) => data.to_selection(),
                Self::Name(data) => data.to_selection(),
                Self::Source(data) => data.to_selection(),
                Self::BookSequences(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _partial_unchecked_sequence { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { $crate :: prisma :: sequence struct $ struct_name { # [serde (rename = "id")] pub id : i32 , # [serde (rename = "source_id")] pub source_id : i32 , # [serde (rename = "remote_id")] pub remote_id : i32 , # [serde (rename = "name")] pub name : String } [$ ($ scalar_field) , +] } } ; }
    pub use _partial_unchecked_sequence as partial_unchecked;
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: i32,
        #[serde(rename = "source_id")]
        pub source_id: i32,
        #[serde(rename = "remote_id")]
        pub remote_id: i32,
        #[serde(rename = "name")]
        pub name: String,
        #[serde(rename = "source")]
        pub source: Option<Box<super::source::Data>>,
        #[serde(rename = "book_sequences")]
        pub book_sequences: Option<Vec<super::book_sequence::Data>>,
    }
    impl Data {
        pub fn source(
            &self,
        ) -> Result<&super::source::Data, ::prisma_client_rust::RelationNotFetchedError> {
            self.source
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(source),
                ))
                .map(|v| v.as_ref())
        }
        pub fn book_sequences(
            &self,
        ) -> Result<&Vec<super::book_sequence::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.book_sequences
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(book_sequences),
                ))
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        Source(super::source::UniqueArgs),
        BookSequences(super::book_sequence::ManyArgs),
    }
    impl From<WithParam> for ::prisma_client_rust::Selection {
        fn from(val: WithParam) -> Self {
            match val {
                WithParam::Source(args) => {
                    let mut selections = < super :: source :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(source::NAME, None, [], selections)
                }
                WithParam::BookSequences(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections . extend (< super :: book_sequence :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
                    ::prisma_client_rust::Selection::new(
                        book_sequences::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(i32),
        IncrementId(i32),
        DecrementId(i32),
        MultiplyId(i32),
        DivideId(i32),
        SetSourceId(i32),
        IncrementSourceId(i32),
        DecrementSourceId(i32),
        MultiplySourceId(i32),
        DivideSourceId(i32),
        SetRemoteId(i32),
        IncrementRemoteId(i32),
        DecrementRemoteId(i32),
        MultiplyRemoteId(i32),
        DivideRemoteId(i32),
        SetName(String),
        ConnectSource(super::source::UniqueWhereParam),
        ConnectBookSequences(Vec<super::book_sequence::UniqueWhereParam>),
        DisconnectBookSequences(Vec<super::book_sequence::UniqueWhereParam>),
        SetBookSequences(Vec<super::book_sequence::UniqueWhereParam>),
    }
    impl From<SetParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(param: SetParam) -> Self {
            match param {
                SetParam::SetId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetSourceId(value) => (
                    source_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementSourceId(value) => (
                    source_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementSourceId(value) => (
                    source_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplySourceId(value) => (
                    source_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideSourceId(value) => (
                    source_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetRemoteId(value) => (
                    remote_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementRemoteId(value) => (
                    remote_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementRemoteId(value) => (
                    remote_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyRemoteId(value) => (
                    remote_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideRemoteId(value) => (
                    remote_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetName(value) => (
                    name::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::ConnectSource(where_param) => (
                    source::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::source::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectBookSequences(where_params) => (
                    book_sequences::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::book_sequence::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectBookSequences(where_params) => (
                    book_sequences::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::book_sequence::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetBookSequences(where_params) => (
                    book_sequences::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::book_sequence::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UncheckedSetParam {
        Id(i32),
        SourceId(i32),
        RemoteId(i32),
        Name(String),
    }
    impl From<UncheckedSetParam> for SetParam {
        fn from(param: UncheckedSetParam) -> Self {
            match param {
                UncheckedSetParam::Id(value) => Self::SetId(value),
                UncheckedSetParam::SourceId(value) => Self::SetSourceId(value),
                UncheckedSetParam::RemoteId(value) => Self::SetRemoteId(value),
                UncheckedSetParam::Name(value) => Self::SetName(value),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        SourceId(::prisma_client_rust::Direction),
        RemoteId(::prisma_client_rust::Direction),
        Name(::prisma_client_rust::Direction),
    }
    impl From<OrderByParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(val: OrderByParam) -> Self {
            match val {
                OrderByParam::Id(direction) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                OrderByParam::SourceId(direction) => (
                    source_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                OrderByParam::RemoteId(direction) => (
                    remote_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                OrderByParam::Name(direction) => (
                    name::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        SourceIdRemoteIdEquals(i32, i32),
        Id(_prisma::read_filters::IntFilter),
        SourceId(_prisma::read_filters::IntFilter),
        RemoteId(_prisma::read_filters::IntFilter),
        Name(_prisma::read_filters::StringFilter),
        SourceIs(Vec<super::source::WhereParam>),
        SourceIsNot(Vec<super::source::WhereParam>),
        BookSequencesSome(Vec<super::book_sequence::WhereParam>),
        BookSequencesEvery(Vec<super::book_sequence::WhereParam>),
        BookSequencesNone(Vec<super::book_sequence::WhereParam>),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::SourceIdRemoteIdEquals(source_id, remote_id) => (
                    "source_id_remote_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![
                        (
                            source_id::NAME.to_string(),
                            ::prisma_client_rust::PrismaValue::Int(source_id as i64),
                        ),
                        (
                            remote_id::NAME.to_string(),
                            ::prisma_client_rust::PrismaValue::Int(remote_id as i64),
                        ),
                    ]),
                ),
                Self::Id(value) => (id::NAME, value.into()),
                Self::SourceId(value) => (source_id::NAME, value.into()),
                Self::RemoteId(value) => (remote_id::NAME, value.into()),
                Self::Name(value) => (name::NAME, value.into()),
                Self::SourceIs(where_params) => (
                    source::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::SourceIsNot(where_params) => (
                    source::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::BookSequencesSome(where_params) => (
                    book_sequences::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::BookSequencesEvery(where_params) => (
                    book_sequences::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::BookSequencesNone(where_params) => (
                    book_sequences::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value)
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        SourceIdRemoteIdEquals(i32, i32),
        IdEquals(i32),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::SourceIdRemoteIdEquals(source_id, remote_id) => {
                    Self::SourceIdRemoteIdEquals(source_id, remote_id)
                }
                UniqueWhereParam::IdEquals(value) => {
                    Self::Id(_prisma::read_filters::IntFilter::Equals(value))
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(id::NAME),
                ::prisma_client_rust::sel(source_id::NAME),
                ::prisma_client_rust::sel(remote_id::NAME),
                ::prisma_client_rust::sel(name::NAME),
            ]
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            remote_id: i32,
            name: String,
            source: super::source::UniqueWhereParam,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.extend([
                remote_id::set(remote_id),
                name::set(name),
                source::connect(source),
            ]);
            Create::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            source_id: i32,
            remote_id: i32,
            name: String,
            mut _params: Vec<UncheckedSetParam>,
        ) -> Create<'a> {
            _params.extend([
                source_id::set(source_id),
                remote_id::set(remote_id),
                name::set(name),
            ]);
            Create::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn create_many(self, data: Vec<(i32, i32, String, Vec<SetParam>)>) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(source_id, remote_id, name, mut _params)| {
                    _params.extend([
                        source_id::set(source_id),
                        remote_id::set(remote_id),
                        name::set(name),
                    ]);
                    _params
                })
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> Update<'a> {
            Update::new(
                self.client,
                _where.into(),
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (remote_id, name, source, mut _params): (
                i32,
                String,
                super::source::UniqueWhereParam,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.extend([
                remote_id::set(remote_id),
                name::set(name),
                source::connect(source),
            ]);
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
        pub fn find_raw<T: ::prisma_client_rust::Data>(
            self,
        ) -> ::prisma_client_rust::FindRaw<'a, Types, T> {
            ::prisma_client_rust::FindRaw::new(self.client)
        }
        pub fn aggregate_raw<T: ::prisma_client_rust::Data>(
            self,
        ) -> ::prisma_client_rust::AggregateRaw<'a, Types, T> {
            ::prisma_client_rust::AggregateRaw::new(self.client)
        }
    }
}
pub mod source {
    
    use super::*;
    pub const NAME: &str = "Source";
    pub mod id {
        use super::super::*;
        
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam,
        };
        pub const NAME: &str = "id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Id, {
            fn in_vec(_: Vec<i32>) -> InVec;
            fn not_in_vec(_: Vec<i32>) -> NotInVec;
            fn lt(_: i32) -> Lt;
            fn lte(_: i32) -> Lte;
            fn gt(_: i32) -> Gt;
            fn gte(_: i32) -> Gte;
            fn not(_: i32) -> Not;
        });
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideId(value)
        }
        pub struct Include;
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::Id(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::Id(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod name {
        use super::super::*;
        
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam,
        };
        pub const NAME: &str = "name";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetName(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Name(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Name(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::NameEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::StringFilter, Name, {
            fn in_vec(_: Vec<String>) -> InVec;
            fn not_in_vec(_: Vec<String>) -> NotInVec;
            fn lt(_: String) -> Lt;
            fn lte(_: String) -> Lte;
            fn gt(_: String) -> Gt;
            fn gte(_: String) -> Gte;
            fn contains(_: String) -> Contains;
            fn starts_with(_: String) -> StartsWith;
            fn ends_with(_: String) -> EndsWith;
            fn mode(_: super::super::QueryMode) -> Mode;
            fn not(_: String) -> Not;
        });
        pub struct Include;
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::Name(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::Name(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod authors {
        use super::super::*;
        
        use super::{
            SetParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "authors";
        pub struct Fetch(pub author::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<author::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: author::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: author::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value);
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Authors(v)
            }
        }
        pub fn fetch(params: Vec<author::WhereParam>) -> Fetch {
            Fetch(author::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<author::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectAuthors(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<author::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<author::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectAuthors(params)
        }
        pub fn set(params: Vec<author::UniqueWhereParam>) -> SetParam {
            SetParam::SetAuthors(params)
        }
        pub fn some(value: Vec<author::WhereParam>) -> WhereParam {
            WhereParam::AuthorsSome(value)
        }
        pub fn every(value: Vec<author::WhereParam>) -> WhereParam {
            WhereParam::AuthorsEvery(value)
        }
        pub fn none(value: Vec<author::WhereParam>) -> WhereParam {
            WhereParam::AuthorsNone(value)
        }
        pub enum Include {
            Select(author::ManyArgs, Vec<author::SelectParam>),
            Include(author::ManyArgs, Vec<author::IncludeParam>),
            Fetch(author::ManyArgs),
        }
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::Authors(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections =
                            <author::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                            );
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <author::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: author::ManyArgs,
                nested_selections: Vec<author::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: author::ManyArgs,
                nested_selections: Vec<author::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(author::ManyArgs, Vec<author::SelectParam>),
            Include(author::ManyArgs, Vec<author::IncludeParam>),
            Fetch(author::ManyArgs),
        }
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::Authors(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <author::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: author::ManyArgs,
                nested_selections: Vec<author::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: author::ManyArgs,
                nested_selections: Vec<author::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub mod books {
        use super::super::*;
        
        use super::{
            SetParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "books";
        pub struct Fetch(pub book::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<book::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: book::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: book::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value);
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Books(v)
            }
        }
        pub fn fetch(params: Vec<book::WhereParam>) -> Fetch {
            Fetch(book::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<book::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectBooks(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<book::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<book::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectBooks(params)
        }
        pub fn set(params: Vec<book::UniqueWhereParam>) -> SetParam {
            SetParam::SetBooks(params)
        }
        pub fn some(value: Vec<book::WhereParam>) -> WhereParam {
            WhereParam::BooksSome(value)
        }
        pub fn every(value: Vec<book::WhereParam>) -> WhereParam {
            WhereParam::BooksEvery(value)
        }
        pub fn none(value: Vec<book::WhereParam>) -> WhereParam {
            WhereParam::BooksNone(value)
        }
        pub enum Include {
            Select(book::ManyArgs, Vec<book::SelectParam>),
            Include(book::ManyArgs, Vec<book::IncludeParam>),
            Fetch(book::ManyArgs),
        }
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::Books(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections =
                            <book::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <book::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(args: book::ManyArgs, nested_selections: Vec<book::SelectParam>) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: book::ManyArgs,
                nested_selections: Vec<book::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(book::ManyArgs, Vec<book::SelectParam>),
            Include(book::ManyArgs, Vec<book::IncludeParam>),
            Fetch(book::ManyArgs),
        }
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::Books(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <book::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(args: book::ManyArgs, nested_selections: Vec<book::SelectParam>) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: book::ManyArgs,
                nested_selections: Vec<book::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub mod genres {
        use super::super::*;
        
        use super::{
            SetParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "genres";
        pub struct Fetch(pub genre::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<genre::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: genre::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: genre::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value);
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Genres(v)
            }
        }
        pub fn fetch(params: Vec<genre::WhereParam>) -> Fetch {
            Fetch(genre::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<genre::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectGenres(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<genre::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<genre::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectGenres(params)
        }
        pub fn set(params: Vec<genre::UniqueWhereParam>) -> SetParam {
            SetParam::SetGenres(params)
        }
        pub fn some(value: Vec<genre::WhereParam>) -> WhereParam {
            WhereParam::GenresSome(value)
        }
        pub fn every(value: Vec<genre::WhereParam>) -> WhereParam {
            WhereParam::GenresEvery(value)
        }
        pub fn none(value: Vec<genre::WhereParam>) -> WhereParam {
            WhereParam::GenresNone(value)
        }
        pub enum Include {
            Select(genre::ManyArgs, Vec<genre::SelectParam>),
            Include(genre::ManyArgs, Vec<genre::IncludeParam>),
            Fetch(genre::ManyArgs),
        }
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::Genres(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections =
                            <genre::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <genre::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: genre::ManyArgs,
                nested_selections: Vec<genre::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: genre::ManyArgs,
                nested_selections: Vec<genre::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(genre::ManyArgs, Vec<genre::SelectParam>),
            Include(genre::ManyArgs, Vec<genre::IncludeParam>),
            Fetch(genre::ManyArgs),
        }
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::Genres(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <genre::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: genre::ManyArgs,
                nested_selections: Vec<genre::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: genre::ManyArgs,
                nested_selections: Vec<genre::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub mod sequences {
        use super::super::*;
        
        use super::{
            SetParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "sequences";
        pub struct Fetch(pub sequence::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<sequence::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: sequence::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: sequence::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value);
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Sequences(v)
            }
        }
        pub fn fetch(params: Vec<sequence::WhereParam>) -> Fetch {
            Fetch(sequence::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<sequence::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectSequences(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<sequence::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<sequence::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectSequences(params)
        }
        pub fn set(params: Vec<sequence::UniqueWhereParam>) -> SetParam {
            SetParam::SetSequences(params)
        }
        pub fn some(value: Vec<sequence::WhereParam>) -> WhereParam {
            WhereParam::SequencesSome(value)
        }
        pub fn every(value: Vec<sequence::WhereParam>) -> WhereParam {
            WhereParam::SequencesEvery(value)
        }
        pub fn none(value: Vec<sequence::WhereParam>) -> WhereParam {
            WhereParam::SequencesNone(value)
        }
        pub enum Include {
            Select(sequence::ManyArgs, Vec<sequence::SelectParam>),
            Include(sequence::ManyArgs, Vec<sequence::IncludeParam>),
            Fetch(sequence::ManyArgs),
        }
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::Sequences(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections = < sequence :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <sequence::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: sequence::ManyArgs,
                nested_selections: Vec<sequence::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: sequence::ManyArgs,
                nested_selections: Vec<sequence::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(sequence::ManyArgs, Vec<sequence::SelectParam>),
            Include(sequence::ManyArgs, Vec<sequence::IncludeParam>),
            Fetch(sequence::ManyArgs),
        }
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::Sequences(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <sequence::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: sequence::ManyArgs,
                nested_selections: Vec<sequence::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: sequence::ManyArgs,
                nested_selections: Vec<sequence::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub fn create(name: String, _params: Vec<SetParam>) -> (String, Vec<SetParam>) {
        (name, _params)
    }
    pub fn create_unchecked(name: String, _params: Vec<SetParam>) -> (String, Vec<SetParam>) {
        (name, _params)
    }
    #[macro_export]
    macro_rules ! _select_source { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $crate :: prisma :: source :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = $crate :: prisma :: source :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: source :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: source :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: source :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: source :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , name , authors , books , genres , sequences } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : crate :: prisma :: source :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: source :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: source :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: source :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: source :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: source :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "name" , "authors" , "books" , "genres" , "sequences"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: source :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i32 } ; (@ field_type ; name) => { String } ; (@ field_type ; authors : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < authors :: Data > } ; (@ field_type ; authors) => { Vec < crate :: prisma :: author :: Data > } ; (@ field_type ; books : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < books :: Data > } ; (@ field_type ; books) => { Vec < crate :: prisma :: book :: Data > } ; (@ field_type ; genres : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < genres :: Data > } ; (@ field_type ; genres) => { Vec < crate :: prisma :: genre :: Data > } ; (@ field_type ; sequences : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < sequences :: Data > } ; (@ field_type ; sequences) => { Vec < crate :: prisma :: sequence :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Source" , available relations are "id, name, authors, books, genres, sequences")) } ; (@ field_module ; authors : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: author :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; books : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: book :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; genres : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: genre :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; sequences : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: sequence :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: source :: SelectParam > :: into (crate :: prisma :: source :: id :: Select) } ; (@ selection_field_to_selection_param ; name) => { Into :: < crate :: prisma :: source :: SelectParam > :: into (crate :: prisma :: source :: name :: Select) } ; (@ selection_field_to_selection_param ; authors $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: source :: SelectParam > :: into (crate :: prisma :: source :: authors :: Select :: $ selection_mode (crate :: prisma :: author :: ManyArgs :: new (crate :: prisma :: author :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: author :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; authors $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: source :: SelectParam > :: into (crate :: prisma :: source :: authors :: Select :: Fetch (crate :: prisma :: author :: ManyArgs :: new (crate :: prisma :: author :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; books $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: source :: SelectParam > :: into (crate :: prisma :: source :: books :: Select :: $ selection_mode (crate :: prisma :: book :: ManyArgs :: new (crate :: prisma :: book :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: book :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; books $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: source :: SelectParam > :: into (crate :: prisma :: source :: books :: Select :: Fetch (crate :: prisma :: book :: ManyArgs :: new (crate :: prisma :: book :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; genres $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: source :: SelectParam > :: into (crate :: prisma :: source :: genres :: Select :: $ selection_mode (crate :: prisma :: genre :: ManyArgs :: new (crate :: prisma :: genre :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: genre :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; genres $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: source :: SelectParam > :: into (crate :: prisma :: source :: genres :: Select :: Fetch (crate :: prisma :: genre :: ManyArgs :: new (crate :: prisma :: genre :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; sequences $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: source :: SelectParam > :: into (crate :: prisma :: source :: sequences :: Select :: $ selection_mode (crate :: prisma :: sequence :: ManyArgs :: new (crate :: prisma :: sequence :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: sequence :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; sequences $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: source :: SelectParam > :: into (crate :: prisma :: source :: sequences :: Select :: Fetch (crate :: prisma :: sequence :: ManyArgs :: new (crate :: prisma :: sequence :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: source :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; authors) => { "authors" } ; (@ field_serde_name ; books) => { "books" } ; (@ field_serde_name ; genres) => { "genres" } ; (@ field_serde_name ; sequences) => { "sequences" } ; }
    pub use _select_source as select;
    pub enum SelectParam {
        Id(id::Select),
        Name(name::Select),
        Authors(authors::Select),
        Books(books::Select),
        Genres(genres::Select),
        Sequences(sequences::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::Name(data) => data.to_selection(),
                Self::Authors(data) => data.to_selection(),
                Self::Books(data) => data.to_selection(),
                Self::Genres(data) => data.to_selection(),
                Self::Sequences(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_source { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $crate :: prisma :: source :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = $crate :: prisma :: source :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: source :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: source :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: source :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: source :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: source :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: source :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { authors , books , genres , sequences } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : i32 , pub name : String , $ (pub $ field : crate :: prisma :: source :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (name)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: source :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: source :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: source :: name :: NAME , & self . name) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , name } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: source :: $ field :: NAME) , + , crate :: prisma :: source :: id :: NAME , crate :: prisma :: source :: name :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: source :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: source :: id :: NAME => Ok (Field :: id) , crate :: prisma :: source :: name :: NAME => Ok (Field :: name) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut name = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: source :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: name => { if name . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: source :: name :: NAME)) ; } name = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: source :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: source :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: source :: id :: NAME)) ? ; let name = name . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: source :: name :: NAME)) ? ; Ok (Data { id , name , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "name" , "authors" , "books" , "genres" , "sequences"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: source :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; authors : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < authors :: Data > } ; (@ field_type ; authors) => { Vec < crate :: prisma :: author :: Data > } ; (@ field_type ; books : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < books :: Data > } ; (@ field_type ; books) => { Vec < crate :: prisma :: book :: Data > } ; (@ field_type ; genres : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < genres :: Data > } ; (@ field_type ; genres) => { Vec < crate :: prisma :: genre :: Data > } ; (@ field_type ; sequences : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < sequences :: Data > } ; (@ field_type ; sequences) => { Vec < crate :: prisma :: sequence :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Source" , available relations are "authors, books, genres, sequences")) } ; (@ field_module ; authors : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: author :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; books : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: book :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; genres : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: genre :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; sequences : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: sequence :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; authors $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: source :: IncludeParam > :: into (crate :: prisma :: source :: authors :: Include :: $ selection_mode (crate :: prisma :: author :: ManyArgs :: new (crate :: prisma :: author :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: author :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; authors $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: source :: IncludeParam > :: into (crate :: prisma :: source :: authors :: Include :: Fetch (crate :: prisma :: author :: ManyArgs :: new (crate :: prisma :: author :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; books $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: source :: IncludeParam > :: into (crate :: prisma :: source :: books :: Include :: $ selection_mode (crate :: prisma :: book :: ManyArgs :: new (crate :: prisma :: book :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: book :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; books $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: source :: IncludeParam > :: into (crate :: prisma :: source :: books :: Include :: Fetch (crate :: prisma :: book :: ManyArgs :: new (crate :: prisma :: book :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; genres $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: source :: IncludeParam > :: into (crate :: prisma :: source :: genres :: Include :: $ selection_mode (crate :: prisma :: genre :: ManyArgs :: new (crate :: prisma :: genre :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: genre :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; genres $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: source :: IncludeParam > :: into (crate :: prisma :: source :: genres :: Include :: Fetch (crate :: prisma :: genre :: ManyArgs :: new (crate :: prisma :: genre :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; sequences $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: source :: IncludeParam > :: into (crate :: prisma :: source :: sequences :: Include :: $ selection_mode (crate :: prisma :: sequence :: ManyArgs :: new (crate :: prisma :: sequence :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: sequence :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; sequences $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: source :: IncludeParam > :: into (crate :: prisma :: source :: sequences :: Include :: Fetch (crate :: prisma :: sequence :: ManyArgs :: new (crate :: prisma :: sequence :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: source :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; authors) => { "authors" } ; (@ field_serde_name ; books) => { "books" } ; (@ field_serde_name ; genres) => { "genres" } ; (@ field_serde_name ; sequences) => { "sequences" } ; }
    pub use _include_source as include;
    pub enum IncludeParam {
        Id(id::Include),
        Name(name::Include),
        Authors(authors::Include),
        Books(books::Include),
        Genres(genres::Include),
        Sequences(sequences::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::Name(data) => data.to_selection(),
                Self::Authors(data) => data.to_selection(),
                Self::Books(data) => data.to_selection(),
                Self::Genres(data) => data.to_selection(),
                Self::Sequences(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _partial_unchecked_source { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { $crate :: prisma :: source struct $ struct_name { # [serde (rename = "id")] pub id : i32 , # [serde (rename = "name")] pub name : String } [$ ($ scalar_field) , +] } } ; }
    pub use _partial_unchecked_source as partial_unchecked;
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: i32,
        #[serde(rename = "name")]
        pub name: String,
        #[serde(rename = "authors")]
        pub authors: Option<Vec<super::author::Data>>,
        #[serde(rename = "books")]
        pub books: Option<Vec<super::book::Data>>,
        #[serde(rename = "genres")]
        pub genres: Option<Vec<super::genre::Data>>,
        #[serde(rename = "sequences")]
        pub sequences: Option<Vec<super::sequence::Data>>,
    }
    impl Data {
        pub fn authors(
            &self,
        ) -> Result<&Vec<super::author::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.authors
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(authors),
                ))
        }
        pub fn books(
            &self,
        ) -> Result<&Vec<super::book::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.books
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(books),
                ))
        }
        pub fn genres(
            &self,
        ) -> Result<&Vec<super::genre::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.genres
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(genres),
                ))
        }
        pub fn sequences(
            &self,
        ) -> Result<&Vec<super::sequence::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.sequences
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(sequences),
                ))
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        Authors(super::author::ManyArgs),
        Books(super::book::ManyArgs),
        Genres(super::genre::ManyArgs),
        Sequences(super::sequence::ManyArgs),
    }
    impl From<WithParam> for ::prisma_client_rust::Selection {
        fn from(val: WithParam) -> Self {
            match val {
                WithParam::Authors(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections . extend (< super :: author :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
                    ::prisma_client_rust::Selection::new(
                        authors::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
                WithParam::Books(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections.extend(
                        <super::book::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                        ),
                    );
                    ::prisma_client_rust::Selection::new(
                        books::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
                WithParam::Genres(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections . extend (< super :: genre :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
                    ::prisma_client_rust::Selection::new(
                        genres::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
                WithParam::Sequences(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections . extend (< super :: sequence :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
                    ::prisma_client_rust::Selection::new(
                        sequences::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(i32),
        IncrementId(i32),
        DecrementId(i32),
        MultiplyId(i32),
        DivideId(i32),
        SetName(String),
        ConnectAuthors(Vec<super::author::UniqueWhereParam>),
        DisconnectAuthors(Vec<super::author::UniqueWhereParam>),
        SetAuthors(Vec<super::author::UniqueWhereParam>),
        ConnectBooks(Vec<super::book::UniqueWhereParam>),
        DisconnectBooks(Vec<super::book::UniqueWhereParam>),
        SetBooks(Vec<super::book::UniqueWhereParam>),
        ConnectGenres(Vec<super::genre::UniqueWhereParam>),
        DisconnectGenres(Vec<super::genre::UniqueWhereParam>),
        SetGenres(Vec<super::genre::UniqueWhereParam>),
        ConnectSequences(Vec<super::sequence::UniqueWhereParam>),
        DisconnectSequences(Vec<super::sequence::UniqueWhereParam>),
        SetSequences(Vec<super::sequence::UniqueWhereParam>),
    }
    impl From<SetParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(param: SetParam) -> Self {
            match param {
                SetParam::SetId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetName(value) => (
                    name::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::ConnectAuthors(where_params) => (
                    authors::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::author::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectAuthors(where_params) => (
                    authors::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::author::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetAuthors(where_params) => (
                    authors::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::author::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectBooks(where_params) => (
                    books::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::book::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectBooks(where_params) => (
                    books::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::book::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetBooks(where_params) => (
                    books::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::book::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectGenres(where_params) => (
                    genres::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::genre::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectGenres(where_params) => (
                    genres::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::genre::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetGenres(where_params) => (
                    genres::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::genre::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectSequences(where_params) => (
                    sequences::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::sequence::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectSequences(where_params) => (
                    sequences::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::sequence::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetSequences(where_params) => (
                    sequences::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::sequence::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UncheckedSetParam {
        Id(i32),
        Name(String),
    }
    impl From<UncheckedSetParam> for SetParam {
        fn from(param: UncheckedSetParam) -> Self {
            match param {
                UncheckedSetParam::Id(value) => Self::SetId(value),
                UncheckedSetParam::Name(value) => Self::SetName(value),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        Name(::prisma_client_rust::Direction),
    }
    impl From<OrderByParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(val: OrderByParam) -> Self {
            match val {
                OrderByParam::Id(direction) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                OrderByParam::Name(direction) => (
                    name::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        Id(_prisma::read_filters::IntFilter),
        Name(_prisma::read_filters::StringFilter),
        AuthorsSome(Vec<super::author::WhereParam>),
        AuthorsEvery(Vec<super::author::WhereParam>),
        AuthorsNone(Vec<super::author::WhereParam>),
        BooksSome(Vec<super::book::WhereParam>),
        BooksEvery(Vec<super::book::WhereParam>),
        BooksNone(Vec<super::book::WhereParam>),
        GenresSome(Vec<super::genre::WhereParam>),
        GenresEvery(Vec<super::genre::WhereParam>),
        GenresNone(Vec<super::genre::WhereParam>),
        SequencesSome(Vec<super::sequence::WhereParam>),
        SequencesEvery(Vec<super::sequence::WhereParam>),
        SequencesNone(Vec<super::sequence::WhereParam>),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Id(value) => (id::NAME, value.into()),
                Self::Name(value) => (name::NAME, value.into()),
                Self::AuthorsSome(where_params) => (
                    authors::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::AuthorsEvery(where_params) => (
                    authors::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::AuthorsNone(where_params) => (
                    authors::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::BooksSome(where_params) => (
                    books::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::BooksEvery(where_params) => (
                    books::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::BooksNone(where_params) => (
                    books::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::GenresSome(where_params) => (
                    genres::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::GenresEvery(where_params) => (
                    genres::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::GenresNone(where_params) => (
                    genres::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::SequencesSome(where_params) => (
                    sequences::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::SequencesEvery(where_params) => (
                    sequences::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::SequencesNone(where_params) => (
                    sequences::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value)
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        NameEquals(String),
        IdEquals(i32),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::NameEquals(value) => {
                    Self::Name(_prisma::read_filters::StringFilter::Equals(value))
                }
                UniqueWhereParam::IdEquals(value) => {
                    Self::Id(_prisma::read_filters::IntFilter::Equals(value))
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(id::NAME),
                ::prisma_client_rust::sel(name::NAME),
            ]
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(self, name: String, mut _params: Vec<SetParam>) -> Create<'a> {
            _params.extend([name::set(name)]);
            Create::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            name: String,
            mut _params: Vec<UncheckedSetParam>,
        ) -> Create<'a> {
            _params.extend([name::set(name)]);
            Create::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn create_many(self, data: Vec<(String, Vec<SetParam>)>) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(name, mut _params)| {
                    _params.extend([name::set(name)]);
                    _params
                })
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> Update<'a> {
            Update::new(
                self.client,
                _where.into(),
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (name, mut _params): (String, Vec<SetParam>),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.extend([name::set(name)]);
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
        pub fn find_raw<T: ::prisma_client_rust::Data>(
            self,
        ) -> ::prisma_client_rust::FindRaw<'a, Types, T> {
            ::prisma_client_rust::FindRaw::new(self.client)
        }
        pub fn aggregate_raw<T: ::prisma_client_rust::Data>(
            self,
        ) -> ::prisma_client_rust::AggregateRaw<'a, Types, T> {
            ::prisma_client_rust::AggregateRaw::new(self.client)
        }
    }
}
pub mod translator {
    
    use super::*;
    pub const NAME: &str = "Translator";
    pub mod id {
        use super::super::*;
        
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam,
        };
        pub const NAME: &str = "id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Id, {
            fn in_vec(_: Vec<i32>) -> InVec;
            fn not_in_vec(_: Vec<i32>) -> NotInVec;
            fn lt(_: i32) -> Lt;
            fn lte(_: i32) -> Lte;
            fn gt(_: i32) -> Gt;
            fn gte(_: i32) -> Gte;
            fn not(_: i32) -> Not;
        });
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideId(value)
        }
        pub struct Include;
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::Id(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::Id(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod position {
        use super::super::*;
        
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "position";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetPosition(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Position(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Position(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::Position(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntFilter,
            Position,
            {
                fn in_vec(_: Vec<i32>) -> InVec;
                fn not_in_vec(_: Vec<i32>) -> NotInVec;
                fn lt(_: i32) -> Lt;
                fn lte(_: i32) -> Lte;
                fn gt(_: i32) -> Gt;
                fn gte(_: i32) -> Gte;
                fn not(_: i32) -> Not;
            }
        );
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementPosition(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementPosition(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyPosition(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DividePosition(value)
        }
        pub struct Include;
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::Position(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::Position(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod author_id {
        use super::super::*;
        
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "author_id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetAuthorId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::AuthorId(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::AuthorId(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::AuthorId(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntFilter,
            AuthorId,
            {
                fn in_vec(_: Vec<i32>) -> InVec;
                fn not_in_vec(_: Vec<i32>) -> NotInVec;
                fn lt(_: i32) -> Lt;
                fn lte(_: i32) -> Lte;
                fn gt(_: i32) -> Gt;
                fn gte(_: i32) -> Gte;
                fn not(_: i32) -> Not;
            }
        );
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementAuthorId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementAuthorId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyAuthorId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideAuthorId(value)
        }
        pub struct Include;
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::AuthorId(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::AuthorId(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod book_id {
        use super::super::*;
        
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, WhereParam,
        };
        pub const NAME: &str = "book_id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetBookId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::BookId(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::BookId(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::BookId(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, BookId, {
            fn in_vec(_: Vec<i32>) -> InVec;
            fn not_in_vec(_: Vec<i32>) -> NotInVec;
            fn lt(_: i32) -> Lt;
            fn lte(_: i32) -> Lte;
            fn gt(_: i32) -> Gt;
            fn gte(_: i32) -> Gte;
            fn not(_: i32) -> Not;
        });
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementBookId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementBookId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyBookId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideBookId(value)
        }
        pub struct Include;
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::BookId(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::BookId(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod author {
        use super::super::*;
        
        use super::{
            SetParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "author";
        pub struct Fetch(pub author::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<author::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Author(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(author::UniqueArgs::new())
        }
        pub struct Connect(author::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectAuthor(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: author::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn is(value: Vec<author::WhereParam>) -> WhereParam {
            WhereParam::AuthorIs(value)
        }
        pub fn is_not(value: Vec<author::WhereParam>) -> WhereParam {
            WhereParam::AuthorIsNot(value)
        }
        pub enum Include {
            Select(Vec<author::SelectParam>),
            Include(Vec<author::IncludeParam>),
            Fetch,
        }
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::Author(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections =
                            <author::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                            );
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <author::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("author", None, [], selections)
            }
            pub fn select(nested_selections: Vec<author::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<author::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<author::SelectParam>),
            Include(Vec<author::IncludeParam>),
            Fetch,
        }
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::Author(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <author::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("author", None, [], selections)
            }
            pub fn select(nested_selections: Vec<author::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<author::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub mod book {
        use super::super::*;
        
        use super::{
            SetParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "book";
        pub struct Fetch(pub book::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<book::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Book(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(book::UniqueArgs::new())
        }
        pub struct Connect(book::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectBook(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: book::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn is(value: Vec<book::WhereParam>) -> WhereParam {
            WhereParam::BookIs(value)
        }
        pub fn is_not(value: Vec<book::WhereParam>) -> WhereParam {
            WhereParam::BookIsNot(value)
        }
        pub enum Include {
            Select(Vec<book::SelectParam>),
            Include(Vec<book::IncludeParam>),
            Fetch,
        }
        impl From<Include> for super::IncludeParam {
            fn from(val: Include) -> Self {
                super::IncludeParam::Book(val)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections =
                            <book::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <book::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("book", None, [], selections)
            }
            pub fn select(nested_selections: Vec<book::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<book::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<book::SelectParam>),
            Include(Vec<book::IncludeParam>),
            Fetch,
        }
        impl From<Select> for super::SelectParam {
            fn from(val: Select) -> Self {
                super::SelectParam::Book(val)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <book::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("book", None, [], selections)
            }
            pub fn select(nested_selections: Vec<book::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<book::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub fn book_id_author_id<T: From<UniqueWhereParam>>(book_id: i32, author_id: i32) -> T {
        UniqueWhereParam::BookIdAuthorIdEquals(book_id, author_id).into()
    }
    pub fn create(
        position: i32,
        author: super::author::UniqueWhereParam,
        book: super::book::UniqueWhereParam,
        _params: Vec<SetParam>,
    ) -> (
        i32,
        super::author::UniqueWhereParam,
        super::book::UniqueWhereParam,
        Vec<SetParam>,
    ) {
        (position, author, book, _params)
    }
    pub fn create_unchecked(
        position: i32,
        author_id: i32,
        book_id: i32,
        _params: Vec<SetParam>,
    ) -> (i32, i32, i32, Vec<SetParam>) {
        (position, author_id, book_id, _params)
    }
    #[macro_export]
    macro_rules ! _select_translator { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $crate :: prisma :: translator :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = $crate :: prisma :: translator :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: translator :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: translator :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: translator :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: translator :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , position , author_id , book_id , author , book } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : crate :: prisma :: translator :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: translator :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: translator :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: translator :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: translator :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: translator :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "position" , "author_id" , "book_id" , "author" , "book"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: translator :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i32 } ; (@ field_type ; position) => { i32 } ; (@ field_type ; author_id) => { i32 } ; (@ field_type ; book_id) => { i32 } ; (@ field_type ; author : $ selection_mode : ident { $ ($ selections : tt) + }) => { author :: Data } ; (@ field_type ; author) => { crate :: prisma :: author :: Data } ; (@ field_type ; book : $ selection_mode : ident { $ ($ selections : tt) + }) => { book :: Data } ; (@ field_type ; book) => { crate :: prisma :: book :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Translator" , available relations are "id, position, author_id, book_id, author, book")) } ; (@ field_module ; author : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: author :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; book : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: book :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: translator :: SelectParam > :: into (crate :: prisma :: translator :: id :: Select) } ; (@ selection_field_to_selection_param ; position) => { Into :: < crate :: prisma :: translator :: SelectParam > :: into (crate :: prisma :: translator :: position :: Select) } ; (@ selection_field_to_selection_param ; author_id) => { Into :: < crate :: prisma :: translator :: SelectParam > :: into (crate :: prisma :: translator :: author_id :: Select) } ; (@ selection_field_to_selection_param ; book_id) => { Into :: < crate :: prisma :: translator :: SelectParam > :: into (crate :: prisma :: translator :: book_id :: Select) } ; (@ selection_field_to_selection_param ; author $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: translator :: SelectParam > :: into (crate :: prisma :: translator :: author :: Select :: $ selection_mode (crate :: prisma :: author :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; author $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: translator :: SelectParam > :: into (crate :: prisma :: translator :: author :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; book $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: translator :: SelectParam > :: into (crate :: prisma :: translator :: book :: Select :: $ selection_mode (crate :: prisma :: book :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; book $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: translator :: SelectParam > :: into (crate :: prisma :: translator :: book :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: translator :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; position) => { "position" } ; (@ field_serde_name ; author_id) => { "author_id" } ; (@ field_serde_name ; book_id) => { "book_id" } ; (@ field_serde_name ; author) => { "author" } ; (@ field_serde_name ; book) => { "book" } ; }
    pub use _select_translator as select;
    pub enum SelectParam {
        Id(id::Select),
        Position(position::Select),
        AuthorId(author_id::Select),
        BookId(book_id::Select),
        Author(author::Select),
        Book(book::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::Position(data) => data.to_selection(),
                Self::AuthorId(data) => data.to_selection(),
                Self::BookId(data) => data.to_selection(),
                Self::Author(data) => data.to_selection(),
                Self::Book(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_translator { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $crate :: prisma :: translator :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = $crate :: prisma :: translator :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: translator :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: translator :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: translator :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: translator :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: translator :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: translator :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { author , book } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : i32 , pub position : i32 , pub author_id : i32 , pub book_id : i32 , $ (pub $ field : crate :: prisma :: translator :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (position) , stringify ! (author_id) , stringify ! (book_id)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: translator :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: translator :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: translator :: position :: NAME , & self . position) ? ; state . serialize_field (crate :: prisma :: translator :: author_id :: NAME , & self . author_id) ? ; state . serialize_field (crate :: prisma :: translator :: book_id :: NAME , & self . book_id) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , position , author_id , book_id } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: translator :: $ field :: NAME) , + , crate :: prisma :: translator :: id :: NAME , crate :: prisma :: translator :: position :: NAME , crate :: prisma :: translator :: author_id :: NAME , crate :: prisma :: translator :: book_id :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: translator :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: translator :: id :: NAME => Ok (Field :: id) , crate :: prisma :: translator :: position :: NAME => Ok (Field :: position) , crate :: prisma :: translator :: author_id :: NAME => Ok (Field :: author_id) , crate :: prisma :: translator :: book_id :: NAME => Ok (Field :: book_id) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut position = None ; let mut author_id = None ; let mut book_id = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: translator :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: position => { if position . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: translator :: position :: NAME)) ; } position = Some (map . next_value () ?) ; } Field :: author_id => { if author_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: translator :: author_id :: NAME)) ; } author_id = Some (map . next_value () ?) ; } Field :: book_id => { if book_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: translator :: book_id :: NAME)) ; } book_id = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: translator :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: translator :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: translator :: id :: NAME)) ? ; let position = position . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: translator :: position :: NAME)) ? ; let author_id = author_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: translator :: author_id :: NAME)) ? ; let book_id = book_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: translator :: book_id :: NAME)) ? ; Ok (Data { id , position , author_id , book_id , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "position" , "author_id" , "book_id" , "author" , "book"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: translator :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; author : $ selection_mode : ident { $ ($ selections : tt) + }) => { author :: Data } ; (@ field_type ; author) => { crate :: prisma :: author :: Data } ; (@ field_type ; book : $ selection_mode : ident { $ ($ selections : tt) + }) => { book :: Data } ; (@ field_type ; book) => { crate :: prisma :: book :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Translator" , available relations are "author, book")) } ; (@ field_module ; author : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: author :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; book : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: book :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; author $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: translator :: IncludeParam > :: into (crate :: prisma :: translator :: author :: Include :: $ selection_mode (crate :: prisma :: author :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; author $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: translator :: IncludeParam > :: into (crate :: prisma :: translator :: author :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; book $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: translator :: IncludeParam > :: into (crate :: prisma :: translator :: book :: Include :: $ selection_mode (crate :: prisma :: book :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; book $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: translator :: IncludeParam > :: into (crate :: prisma :: translator :: book :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: translator :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; position) => { "position" } ; (@ field_serde_name ; author_id) => { "author_id" } ; (@ field_serde_name ; book_id) => { "book_id" } ; (@ field_serde_name ; author) => { "author" } ; (@ field_serde_name ; book) => { "book" } ; }
    pub use _include_translator as include;
    pub enum IncludeParam {
        Id(id::Include),
        Position(position::Include),
        AuthorId(author_id::Include),
        BookId(book_id::Include),
        Author(author::Include),
        Book(book::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::Position(data) => data.to_selection(),
                Self::AuthorId(data) => data.to_selection(),
                Self::BookId(data) => data.to_selection(),
                Self::Author(data) => data.to_selection(),
                Self::Book(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _partial_unchecked_translator { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { $crate :: prisma :: translator struct $ struct_name { # [serde (rename = "id")] pub id : i32 , # [serde (rename = "position")] pub position : i32 , # [serde (rename = "author_id")] pub author_id : i32 , # [serde (rename = "book_id")] pub book_id : i32 } [$ ($ scalar_field) , +] } } ; }
    pub use _partial_unchecked_translator as partial_unchecked;
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: i32,
        #[serde(rename = "position")]
        pub position: i32,
        #[serde(rename = "author_id")]
        pub author_id: i32,
        #[serde(rename = "book_id")]
        pub book_id: i32,
        #[serde(rename = "author")]
        pub author: Option<Box<super::author::Data>>,
        #[serde(rename = "book")]
        pub book: Option<Box<super::book::Data>>,
    }
    impl Data {
        pub fn author(
            &self,
        ) -> Result<&super::author::Data, ::prisma_client_rust::RelationNotFetchedError> {
            self.author
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(author),
                ))
                .map(|v| v.as_ref())
        }
        pub fn book(
            &self,
        ) -> Result<&super::book::Data, ::prisma_client_rust::RelationNotFetchedError> {
            self.book
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(book),
                ))
                .map(|v| v.as_ref())
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        Author(super::author::UniqueArgs),
        Book(super::book::UniqueArgs),
    }
    impl From<WithParam> for ::prisma_client_rust::Selection {
        fn from(val: WithParam) -> Self {
            match val {
                WithParam::Author(args) => {
                    let mut selections = < super :: author :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(author::NAME, None, [], selections)
                }
                WithParam::Book(args) => {
                    let mut selections =
                        <super::book::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                        );
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(book::NAME, None, [], selections)
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(i32),
        IncrementId(i32),
        DecrementId(i32),
        MultiplyId(i32),
        DivideId(i32),
        SetPosition(i32),
        IncrementPosition(i32),
        DecrementPosition(i32),
        MultiplyPosition(i32),
        DividePosition(i32),
        SetAuthorId(i32),
        IncrementAuthorId(i32),
        DecrementAuthorId(i32),
        MultiplyAuthorId(i32),
        DivideAuthorId(i32),
        SetBookId(i32),
        IncrementBookId(i32),
        DecrementBookId(i32),
        MultiplyBookId(i32),
        DivideBookId(i32),
        ConnectAuthor(super::author::UniqueWhereParam),
        ConnectBook(super::book::UniqueWhereParam),
    }
    impl From<SetParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(param: SetParam) -> Self {
            match param {
                SetParam::SetId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetPosition(value) => (
                    position::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementPosition(value) => (
                    position::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementPosition(value) => (
                    position::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyPosition(value) => (
                    position::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DividePosition(value) => (
                    position::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetAuthorId(value) => (
                    author_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementAuthorId(value) => (
                    author_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementAuthorId(value) => (
                    author_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyAuthorId(value) => (
                    author_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideAuthorId(value) => (
                    author_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetBookId(value) => (
                    book_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementBookId(value) => (
                    book_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementBookId(value) => (
                    book_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyBookId(value) => (
                    book_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideBookId(value) => (
                    book_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::ConnectAuthor(where_param) => (
                    author::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::author::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectBook(where_param) => (
                    book::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::book::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UncheckedSetParam {
        Id(i32),
        Position(i32),
        AuthorId(i32),
        BookId(i32),
    }
    impl From<UncheckedSetParam> for SetParam {
        fn from(param: UncheckedSetParam) -> Self {
            match param {
                UncheckedSetParam::Id(value) => Self::SetId(value),
                UncheckedSetParam::Position(value) => Self::SetPosition(value),
                UncheckedSetParam::AuthorId(value) => Self::SetAuthorId(value),
                UncheckedSetParam::BookId(value) => Self::SetBookId(value),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        Position(::prisma_client_rust::Direction),
        AuthorId(::prisma_client_rust::Direction),
        BookId(::prisma_client_rust::Direction),
    }
    impl From<OrderByParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(val: OrderByParam) -> Self {
            match val {
                OrderByParam::Id(direction) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                OrderByParam::Position(direction) => (
                    position::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                OrderByParam::AuthorId(direction) => (
                    author_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                OrderByParam::BookId(direction) => (
                    book_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        BookIdAuthorIdEquals(i32, i32),
        Id(_prisma::read_filters::IntFilter),
        Position(_prisma::read_filters::IntFilter),
        AuthorId(_prisma::read_filters::IntFilter),
        BookId(_prisma::read_filters::IntFilter),
        AuthorIs(Vec<super::author::WhereParam>),
        AuthorIsNot(Vec<super::author::WhereParam>),
        BookIs(Vec<super::book::WhereParam>),
        BookIsNot(Vec<super::book::WhereParam>),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::BookIdAuthorIdEquals(book_id, author_id) => (
                    "book_id_author_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![
                        (
                            book_id::NAME.to_string(),
                            ::prisma_client_rust::PrismaValue::Int(book_id as i64),
                        ),
                        (
                            author_id::NAME.to_string(),
                            ::prisma_client_rust::PrismaValue::Int(author_id as i64),
                        ),
                    ]),
                ),
                Self::Id(value) => (id::NAME, value.into()),
                Self::Position(value) => (position::NAME, value.into()),
                Self::AuthorId(value) => (author_id::NAME, value.into()),
                Self::BookId(value) => (book_id::NAME, value.into()),
                Self::AuthorIs(where_params) => (
                    author::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::AuthorIsNot(where_params) => (
                    author::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::BookIs(where_params) => (
                    book::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::BookIsNot(where_params) => (
                    book::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value)
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        BookIdAuthorIdEquals(i32, i32),
        IdEquals(i32),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::BookIdAuthorIdEquals(book_id, author_id) => {
                    Self::BookIdAuthorIdEquals(book_id, author_id)
                }
                UniqueWhereParam::IdEquals(value) => {
                    Self::Id(_prisma::read_filters::IntFilter::Equals(value))
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(id::NAME),
                ::prisma_client_rust::sel(position::NAME),
                ::prisma_client_rust::sel(author_id::NAME),
                ::prisma_client_rust::sel(book_id::NAME),
            ]
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            position: i32,
            author: super::author::UniqueWhereParam,
            book: super::book::UniqueWhereParam,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.extend([
                position::set(position),
                author::connect(author),
                book::connect(book),
            ]);
            Create::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            position: i32,
            author_id: i32,
            book_id: i32,
            mut _params: Vec<UncheckedSetParam>,
        ) -> Create<'a> {
            _params.extend([
                position::set(position),
                author_id::set(author_id),
                book_id::set(book_id),
            ]);
            Create::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn create_many(self, data: Vec<(i32, i32, i32, Vec<SetParam>)>) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(position, author_id, book_id, mut _params)| {
                    _params.extend([
                        position::set(position),
                        author_id::set(author_id),
                        book_id::set(book_id),
                    ]);
                    _params
                })
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> Update<'a> {
            Update::new(
                self.client,
                _where.into(),
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (position, author, book, mut _params): (
                i32,
                super::author::UniqueWhereParam,
                super::book::UniqueWhereParam,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.extend([
                position::set(position),
                author::connect(author),
                book::connect(book),
            ]);
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
        pub fn find_raw<T: ::prisma_client_rust::Data>(
            self,
        ) -> ::prisma_client_rust::FindRaw<'a, Types, T> {
            ::prisma_client_rust::FindRaw::new(self.client)
        }
        pub fn aggregate_raw<T: ::prisma_client_rust::Data>(
            self,
        ) -> ::prisma_client_rust::AggregateRaw<'a, Types, T> {
            ::prisma_client_rust::AggregateRaw::new(self.client)
        }
    }
}
pub mod _prisma {
    pub struct PrismaClientBuilder {
        url: Option<String>,
        action_notifier: ::prisma_client_rust::ActionNotifier,
    }
    impl PrismaClientBuilder {
        fn new() -> Self {
            Self {
                url: None,
                action_notifier: ::prisma_client_rust::ActionNotifier::new(),
            }
        }
        pub fn with_url(mut self, url: String) -> Self {
            self.url = Some(url);
            self
        }
        pub async fn build(self) -> Result<PrismaClient, ::prisma_client_rust::NewClientError> {
            let internals = ::prisma_client_rust::PrismaClientInternals::new(
                self.url,
                self.action_notifier,
                super::DATAMODEL_STR,
            )
            .await?;
            Ok(PrismaClient(internals))
        }
    }
    pub struct PrismaClient(::prisma_client_rust::PrismaClientInternals);
    impl ::std::fmt::Debug for PrismaClient {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.debug_struct("PrismaClient").finish()
        }
    }
    impl PrismaClient {
        pub fn _builder() -> PrismaClientBuilder {
            PrismaClientBuilder::new()
        }
        pub fn _query_raw<T: ::prisma_client_rust::Data>(
            &self,
            query: ::prisma_client_rust::Raw,
        ) -> ::prisma_client_rust::QueryRaw<T> {
            ::prisma_client_rust::QueryRaw::new(&self.0, query, super::DATABASE_STR)
        }
        pub fn _execute_raw(
            &self,
            query: ::prisma_client_rust::Raw,
        ) -> ::prisma_client_rust::ExecuteRaw {
            ::prisma_client_rust::ExecuteRaw::new(&self.0, query, super::DATABASE_STR)
        }
        pub async fn _batch<
            'batch,
            T: ::prisma_client_rust::BatchContainer<'batch, Marker>,
            Marker,
        >(
            &self,
            queries: T,
        ) -> ::prisma_client_rust::Result<
            <T as ::prisma_client_rust::BatchContainer<'batch, Marker>>::ReturnType,
        > {
            ::prisma_client_rust::batch(queries, &self.0).await
        }
        pub fn _transaction(&self) -> ::prisma_client_rust::TransactionBuilder<Self> {
            ::prisma_client_rust::TransactionBuilder::_new(self, &self.0)
        }
        pub fn author_annotation(&self) -> super::author_annotation::Actions {
            super::author_annotation::Actions { client: &self.0 }
        }
        pub fn author(&self) -> super::author::Actions {
            super::author::Actions { client: &self.0 }
        }
        pub fn book_annotation(&self) -> super::book_annotation::Actions {
            super::book_annotation::Actions { client: &self.0 }
        }
        pub fn book_author(&self) -> super::book_author::Actions {
            super::book_author::Actions { client: &self.0 }
        }
        pub fn book_genre(&self) -> super::book_genre::Actions {
            super::book_genre::Actions { client: &self.0 }
        }
        pub fn book_sequence(&self) -> super::book_sequence::Actions {
            super::book_sequence::Actions { client: &self.0 }
        }
        pub fn book(&self) -> super::book::Actions {
            super::book::Actions { client: &self.0 }
        }
        pub fn genre(&self) -> super::genre::Actions {
            super::genre::Actions { client: &self.0 }
        }
        pub fn sequence(&self) -> super::sequence::Actions {
            super::sequence::Actions { client: &self.0 }
        }
        pub fn source(&self) -> super::source::Actions {
            super::source::Actions { client: &self.0 }
        }
        pub fn translator(&self) -> super::translator::Actions {
            super::translator::Actions { client: &self.0 }
        }
    }
    impl ::prisma_client_rust::PrismaClient for PrismaClient {
        fn internals(&self) -> &::prisma_client_rust::PrismaClientInternals {
            &self.0
        }
        fn internals_mut(&mut self) -> &mut ::prisma_client_rust::PrismaClientInternals {
            &mut self.0
        }
        fn with_tx_id(&self, tx_id: Option<::prisma_client_rust::query_core::TxId>) -> Self {
            Self(self.0.with_tx_id(tx_id))
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum AuthorAnnotationScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "author_id")]
        AuthorId,
        #[serde(rename = "title")]
        Title,
        #[serde(rename = "text")]
        Text,
        #[serde(rename = "file")]
        File,
    }
    impl ToString for AuthorAnnotationScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::AuthorId => "author_id".to_string(),
                Self::Title => "title".to_string(),
                Self::Text => "text".to_string(),
                Self::File => "file".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum AuthorScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "source_id")]
        SourceId,
        #[serde(rename = "remote_id")]
        RemoteId,
        #[serde(rename = "first_name")]
        FirstName,
        #[serde(rename = "last_name")]
        LastName,
        #[serde(rename = "middle_name")]
        MiddleName,
    }
    impl ToString for AuthorScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::SourceId => "source_id".to_string(),
                Self::RemoteId => "remote_id".to_string(),
                Self::FirstName => "first_name".to_string(),
                Self::LastName => "last_name".to_string(),
                Self::MiddleName => "middle_name".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum BookAnnotationScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "book_id")]
        BookId,
        #[serde(rename = "title")]
        Title,
        #[serde(rename = "text")]
        Text,
        #[serde(rename = "file")]
        File,
    }
    impl ToString for BookAnnotationScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::BookId => "book_id".to_string(),
                Self::Title => "title".to_string(),
                Self::Text => "text".to_string(),
                Self::File => "file".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum BookAuthorScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "author_id")]
        AuthorId,
        #[serde(rename = "book_id")]
        BookId,
    }
    impl ToString for BookAuthorScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::AuthorId => "author_id".to_string(),
                Self::BookId => "book_id".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum BookGenreScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "genre_id")]
        GenreId,
        #[serde(rename = "book_id")]
        BookId,
    }
    impl ToString for BookGenreScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::GenreId => "genre_id".to_string(),
                Self::BookId => "book_id".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum BookScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "source_id")]
        SourceId,
        #[serde(rename = "remote_id")]
        RemoteId,
        #[serde(rename = "title")]
        Title,
        #[serde(rename = "lang")]
        Lang,
        #[serde(rename = "file_type")]
        FileType,
        #[serde(rename = "uploaded")]
        Uploaded,
        #[serde(rename = "is_deleted")]
        IsDeleted,
        #[serde(rename = "pages")]
        Pages,
    }
    impl ToString for BookScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::SourceId => "source_id".to_string(),
                Self::RemoteId => "remote_id".to_string(),
                Self::Title => "title".to_string(),
                Self::Lang => "lang".to_string(),
                Self::FileType => "file_type".to_string(),
                Self::Uploaded => "uploaded".to_string(),
                Self::IsDeleted => "is_deleted".to_string(),
                Self::Pages => "pages".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum BookSequenceScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "position")]
        Position,
        #[serde(rename = "sequence_id")]
        SequenceId,
        #[serde(rename = "book_id")]
        BookId,
    }
    impl ToString for BookSequenceScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::Position => "position".to_string(),
                Self::SequenceId => "sequence_id".to_string(),
                Self::BookId => "book_id".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum GenreScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "source_id")]
        SourceId,
        #[serde(rename = "remote_id")]
        RemoteId,
        #[serde(rename = "code")]
        Code,
        #[serde(rename = "description")]
        Description,
        #[serde(rename = "meta")]
        Meta,
    }
    impl ToString for GenreScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::SourceId => "source_id".to_string(),
                Self::RemoteId => "remote_id".to_string(),
                Self::Code => "code".to_string(),
                Self::Description => "description".to_string(),
                Self::Meta => "meta".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum QueryMode {
        #[serde(rename = "default")]
        Default,
        #[serde(rename = "insensitive")]
        Insensitive,
    }
    impl ToString for QueryMode {
        fn to_string(&self) -> String {
            match self {
                Self::Default => "default".to_string(),
                Self::Insensitive => "insensitive".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum SequenceScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "source_id")]
        SourceId,
        #[serde(rename = "remote_id")]
        RemoteId,
        #[serde(rename = "name")]
        Name,
    }
    impl ToString for SequenceScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::SourceId => "source_id".to_string(),
                Self::RemoteId => "remote_id".to_string(),
                Self::Name => "name".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum SortOrder {
        #[serde(rename = "asc")]
        Asc,
        #[serde(rename = "desc")]
        Desc,
    }
    impl ToString for SortOrder {
        fn to_string(&self) -> String {
            match self {
                Self::Asc => "asc".to_string(),
                Self::Desc => "desc".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum SourceScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "name")]
        Name,
    }
    impl ToString for SourceScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::Name => "name".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum TransactionIsolationLevel {
        #[serde(rename = "ReadUncommitted")]
        ReadUncommitted,
        #[serde(rename = "ReadCommitted")]
        ReadCommitted,
        #[serde(rename = "RepeatableRead")]
        RepeatableRead,
        #[serde(rename = "Serializable")]
        Serializable,
    }
    impl ToString for TransactionIsolationLevel {
        fn to_string(&self) -> String {
            match self {
                Self::ReadUncommitted => "ReadUncommitted".to_string(),
                Self::ReadCommitted => "ReadCommitted".to_string(),
                Self::RepeatableRead => "RepeatableRead".to_string(),
                Self::Serializable => "Serializable".to_string(),
            }
        }
    }
    impl ::prisma_client_rust::TransactionIsolationLevel for TransactionIsolationLevel {}
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum TranslatorScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "position")]
        Position,
        #[serde(rename = "author_id")]
        AuthorId,
        #[serde(rename = "book_id")]
        BookId,
    }
    impl ToString for TranslatorScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::Position => "position".to_string(),
                Self::AuthorId => "author_id".to_string(),
                Self::BookId => "book_id".to_string(),
            }
        }
    }
    pub mod read_filters {
        #[derive(Clone)]
        pub enum IntFilter {
            Equals(i32),
            InVec(Vec<i32>),
            NotInVec(Vec<i32>),
            Lt(i32),
            Lte(i32),
            Gt(i32),
            Gte(i32),
            Not(i32),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for IntFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self {
                    Self::Equals(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "equals".to_string(),
                            ::prisma_client_rust::PrismaValue::Int(value as i64),
                        )])
                    }
                    Self::InVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "in".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| {
                                        ::prisma_client_rust::PrismaValue::Int(value as i64)
                                    })
                                    .collect(),
                            ),
                        )])
                    }
                    Self::NotInVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "notIn".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| {
                                        ::prisma_client_rust::PrismaValue::Int(value as i64)
                                    })
                                    .collect(),
                            ),
                        )])
                    }
                    Self::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                    Self::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                    Self::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                    Self::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                    Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                }
            }
        }
        #[derive(Clone)]
        pub enum IntNullableFilter {
            Equals(Option<i32>),
            InVec(Vec<i32>),
            NotInVec(Vec<i32>),
            Lt(i32),
            Lte(i32),
            Gt(i32),
            Gte(i32),
            Not(Option<i32>),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for IntNullableFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self {
                    Self::Equals(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "equals".to_string(),
                            value
                                .map(|value| ::prisma_client_rust::PrismaValue::Int(value as i64))
                                .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                        )])
                    }
                    Self::InVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "in".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| {
                                        ::prisma_client_rust::PrismaValue::Int(value as i64)
                                    })
                                    .collect(),
                            ),
                        )])
                    }
                    Self::NotInVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "notIn".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| {
                                        ::prisma_client_rust::PrismaValue::Int(value as i64)
                                    })
                                    .collect(),
                            ),
                        )])
                    }
                    Self::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                    Self::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                    Self::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                    Self::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                    Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        value
                            .map(|value| ::prisma_client_rust::PrismaValue::Int(value as i64))
                            .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                    )]),
                }
            }
        }
        #[derive(Clone)]
        pub enum StringFilter {
            Equals(String),
            InVec(Vec<String>),
            NotInVec(Vec<String>),
            Lt(String),
            Lte(String),
            Gt(String),
            Gte(String),
            Contains(String),
            StartsWith(String),
            EndsWith(String),
            Mode(super::super::QueryMode),
            Not(String),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for StringFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self {
                    Self::Equals(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "equals".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )])
                    }
                    Self::InVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "in".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(::prisma_client_rust::PrismaValue::String)
                                    .collect(),
                            ),
                        )])
                    }
                    Self::NotInVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "notIn".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(::prisma_client_rust::PrismaValue::String)
                                    .collect(),
                            ),
                        )])
                    }
                    Self::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    Self::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    Self::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    Self::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    Self::Contains(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "contains".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )])
                    }
                    Self::StartsWith(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "startsWith".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )])
                    }
                    Self::EndsWith(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "endsWith".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )])
                    }
                    Self::Mode(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "mode".to_string(),
                            ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                        )])
                    }
                    Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                }
            }
        }
        #[derive(Clone)]
        pub enum StringNullableFilter {
            Equals(Option<String>),
            InVec(Vec<String>),
            NotInVec(Vec<String>),
            Lt(String),
            Lte(String),
            Gt(String),
            Gte(String),
            Contains(String),
            StartsWith(String),
            EndsWith(String),
            Mode(super::super::QueryMode),
            Not(Option<String>),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for StringNullableFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self {
                    Self::Equals(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "equals".to_string(),
                            value
                                .map(::prisma_client_rust::PrismaValue::String)
                                .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                        )])
                    }
                    Self::InVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "in".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(::prisma_client_rust::PrismaValue::String)
                                    .collect(),
                            ),
                        )])
                    }
                    Self::NotInVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "notIn".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(::prisma_client_rust::PrismaValue::String)
                                    .collect(),
                            ),
                        )])
                    }
                    Self::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    Self::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    Self::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    Self::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    Self::Contains(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "contains".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )])
                    }
                    Self::StartsWith(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "startsWith".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )])
                    }
                    Self::EndsWith(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "endsWith".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )])
                    }
                    Self::Mode(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "mode".to_string(),
                            ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                        )])
                    }
                    Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        value
                            .map(::prisma_client_rust::PrismaValue::String)
                            .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                    )]),
                }
            }
        }
        #[derive(Clone)]
        pub enum DateTimeFilter {
            Equals(
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            ),
            InVec(
                Vec<
                    ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                >,
            ),
            NotInVec(
                Vec<
                    ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                >,
            ),
            Lt(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
            Lte(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
            Gt(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
            Gte(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
            Not(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for DateTimeFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self {
                    Self::Equals(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "equals".to_string(),
                            ::prisma_client_rust::PrismaValue::DateTime(value),
                        )])
                    }
                    Self::InVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "in".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(::prisma_client_rust::PrismaValue::DateTime)
                                    .collect(),
                            ),
                        )])
                    }
                    Self::NotInVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "notIn".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(::prisma_client_rust::PrismaValue::DateTime)
                                    .collect(),
                            ),
                        )])
                    }
                    Self::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                    Self::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                    Self::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                    Self::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                    Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                }
            }
        }
        #[derive(Clone)]
        pub enum BoolFilter {
            Equals(bool),
            Not(bool),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for BoolFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self {
                    Self::Equals(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "equals".to_string(),
                            ::prisma_client_rust::PrismaValue::Boolean(value),
                        )])
                    }
                    Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::Boolean(value),
                    )]),
                }
            }
        }
    }
}
pub use _prisma::*;
